{"version":3,"sources":["inversify.js","node_modules/browser-pack/_prelude.js","src/annotation/decorator_utils.ts","src/annotation/inject.ts","src/annotation/injectable.ts","src/annotation/multi_inject.ts","src/annotation/named.ts","src/annotation/param_name.ts","src/annotation/tagged.ts","src/bindings/binding.ts","src/bindings/binding_count.ts","src/bindings/binding_scope.ts","src/bindings/binding_type.ts","src/constants/error_msgs.ts","src/constants/metadata_keys.ts","src/inversify.ts","src/kernel/kernel.ts","src/kernel/key_value_pair.ts","src/kernel/lookup.ts","src/planning/context.ts","src/planning/metadata.ts","src/planning/plan.ts","src/planning/planner.ts","src/planning/queryable_string.ts","src/planning/request.ts","src/planning/target.ts","src/resolution/resolver.ts","src/syntax/binding_in_syntax.ts","src/syntax/binding_in_when_on_syntax.ts","src/syntax/binding_on_syntax.ts","src/syntax/binding_to_syntax.ts","src/syntax/binding_when_on_syntax.ts","src/syntax/binding_when_syntax.ts","src/syntax/constraint_helpers.ts"],"names":[],"mappings":"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","file":"inversify.js","sourcesContent":[null,"(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\nimport * as ERROR_MSGS from \"../constants/error_msgs\";\n\ninterface IReflectResult {\n    [key: string]: IMetadata[];\n}\n\nfunction tagParameter(target: any, targetKey: string, index: number, metadata: IMetadata) {\n\n    let paramsMetadata: IReflectResult = null;\n\n    // this decorator can be used in a constructor not a method\n    if (targetKey !== undefined) {\n        throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);\n    }\n\n    // read metadata if avalible\n    if (Reflect.hasOwnMetadata(METADATA_KEY.TAGGED, target) !== true) {\n        paramsMetadata = {};\n    } else {\n        paramsMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED, target);\n    }\n\n    // get metadata for the decorated parameter by its index\n    let paramMetadata: IMetadata[] = paramsMetadata[index.toString()];\n    if (Array.isArray(paramMetadata) !== true) {\n        paramMetadata = [];\n    } else {\n        for (let i = 0; i < paramMetadata.length; i++) {\n            let m: IMetadata = paramMetadata[i];\n            if (m.key === metadata.key) {\n                throw new Error(`${ERROR_MSGS.DUPLICATED_METADATA} ${m.key}`);\n            }\n        }\n    }\n\n    // set metadata\n    paramMetadata.push(metadata);\n    paramsMetadata[index.toString()] = paramMetadata;\n    Reflect.defineMetadata(METADATA_KEY.TAGGED, paramsMetadata, target);\n    return target;\n}\n\nfunction _decorate(decorators: ClassDecorator[], target: any): void {\n    Reflect.decorate(decorators, target);\n}\n\nfunction _param(paramIndex: number, decorator: ParameterDecorator): ClassDecorator {\n    return function (target: any, key?: string) { decorator(target, key, paramIndex); };\n}\n\n// Allows VanillaJS developers to use decorators:\n// decorate(injectable(\"IFoo\", \"IBar\"), FooBar);\n// decorate(paramNames(\"foo\", \"bar\"), FooBar);\n// decorate(named(\"foo\"), FooBar, 0);\n// decorate(tagged(\"bar\"), FooBar, 1);\nfunction decorate(\n    decorator: (ClassDecorator|ParameterDecorator),\n    target: any,\n    parameterIndex?: number): void {\n\n    if (typeof parameterIndex === \"number\") {\n        _decorate([_param(parameterIndex, <ParameterDecorator>decorator)], target);\n    } else {\n        _decorate([<ClassDecorator>decorator], target);\n    }\n}\n\nexport { decorate, tagParameter };\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\r\n\r\nimport Metadata from \"../planning/metadata\";\r\nimport { tagParameter } from \"./decorator_utils\";\r\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\r\n\r\n// Used to declare types to be injected not available at runtime\r\nfunction inject(serviceIdentifier: (string|Symbol)) {\r\n  return function(target: any, targetKey: string, index: number) {\r\n    let metadata = new Metadata(METADATA_KEY.INJECT_TAG, serviceIdentifier);\r\n    return tagParameter(target, targetKey, index, metadata);\r\n  };\r\n}\r\n\r\nexport default inject;\r\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\nimport * as ERRORS_MSGS from \"../constants/error_msgs\";\n\nfunction injectable() {\n  return function(target: any) {\n\n    if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target) === true) {\n      throw new Error(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);\n    }\n\n    let types = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, target) || [];\n    Reflect.defineMetadata(METADATA_KEY.PARAM_TYPES, types, target);\n\n    return target;\n  };\n}\n\nexport default injectable;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport Metadata from \"../planning/metadata\";\nimport { tagParameter } from \"./decorator_utils\";\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\n\nfunction multiInject(serviceIdentifier: (string|Symbol)) {\n  return function(target: any, targetKey: string, index: number) {\n    let metadata = new Metadata(METADATA_KEY.MULTI_INJECT_TAG, serviceIdentifier);\n    return tagParameter(target, targetKey, index, metadata);\n  };\n}\n\nexport default multiInject;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\r\n\r\nimport Metadata from \"../planning/metadata\";\r\nimport { tagParameter } from \"./decorator_utils\";\r\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\r\n\r\n// Used to add named metadata which is used to resolve name-based contextual bindings.\r\nfunction named(name: string) {\r\n  return function(target: any, targetKey: string, index: number) {\r\n    let metadata = new Metadata(METADATA_KEY.NAMED_TAG, name);\r\n    return tagParameter(target, targetKey, index, metadata);\r\n  };\r\n}\r\n\r\nexport default named;\r\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport Metadata from \"../planning/metadata\";\nimport { tagParameter } from \"./decorator_utils\";\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\n\nfunction paramName(name: string) {\n  return function(target: any, targetKey: string, index: number) {\n    let metadata = new Metadata(METADATA_KEY.NAME_TAG, name);\n    return tagParameter(target, targetKey, index, metadata);\n  };\n}\n\nexport default paramName;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport Metadata from \"../planning/metadata\";\nimport { tagParameter } from \"./decorator_utils\";\n\n// Used to add custom metadata which is used to resolve metadata-based contextual bindings.\nfunction tagged(metadataKey: string, metadataValue: any) {\n    return function(target: any, targetKey: string, index: number) {\n        let metadata = new Metadata(metadataKey, metadataValue);\n        return tagParameter(target, targetKey, index, metadata);\n    };\n}\n\nexport default tagged;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\n// Binding\n// -----------\n\n// A type binding (or just a binding) is a mapping between a service type\n// (an interface), and an implementation type to be used to satisfy such\n// a service requirement.\n\nimport BindingScope from \"./binding_scope\";\nimport BindingType from \"./binding_type\";\n\nclass Binding<T> implements IBinding<T> {\n\n    // Determines wether the bindings has been already activated\n    // The activation action takes place when an instance is resolved\n    // If the scope is singleton it only happens once\n    public activated: boolean;\n\n    // A runtime identifier because at runtime we don't have interfaces\n    public serviceIdentifier: (string|Symbol|INewable<T>);\n\n    // The constructor of a class which must implement T\n    public implementationType: INewable<T>;\n\n    // Cache used to allow singleton scope and BindingType.Value bindings\n    public cache: T;\n\n    // The scope mode to be used\n    public scope: BindingScope;\n\n    // The kind of binding\n    public type: BindingType;\n\n    // A factory method used in BindingType.Factory bindings\n    public factory: IFactoryCreator<T>;\n\n    // An async factory method used in BindingType.Provider bindings\n    public provider: IProviderCreator<T>;\n\n    // A constraint used to limit the contexts in which this binding is applicable\n    public constraint: (request: IRequest) => boolean;\n\n    // On activation handler (invoked just before an instance is added to cache and injected)\n    public onActivation: (context: IContext, injectable: T) => T;\n\n    constructor(serviceIdentifier: (string|Symbol|INewable<T>)) {\n        this.activated = false;\n        this.serviceIdentifier = serviceIdentifier;\n        this.scope = BindingScope.Transient;\n        this.type = BindingType.Invalid;\n        this.constraint = (request: IRequest) => { return true; };\n        this.implementationType = null;\n        this.cache = null;\n        this.factory = null;\n        this.provider = null;\n        this.onActivation = null;\n    }\n}\n\nexport default Binding;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nenum BindingCount {\n    NoBindingsAvailable = 0,\n    OnlyOneBindingAvailable = 1,\n    MultipleBindingsAvailable = 2\n}\n\nexport default BindingCount;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nenum BindingScope {\n  Transient = 0,\n  Singleton = 1\n}\n\nexport default BindingScope;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nenum BindingType {\n  Invalid = 0,\n  Instance = 1,\n  Value = 2,\n  Constructor = 3,\n  Factory = 4,\n  Provider = 5\n}\n\nexport default BindingType;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nexport const DUPLICATED_INJECTABLE_DECORATOR = \"Cannot apply @injectable decorator multiple times.\";\nexport const DUPLICATED_METADATA = \"Metadadata key was used more than once in a parameter:\";\nexport const NULL_ARGUMENT = \"NULL argument\";\nexport const KEY_NOT_FOUND = \"Key Not Found\";\nexport const AMBIGUOUS_MATCH = \"Ambiguous match found for serviceIdentifier:\";\nexport const CANNOT_UNBIND = \"Could not unbind serviceIdentifier:\";\nexport const NOT_REGISTERED = \"No bindigns found for serviceIdentifier:\";\nexport const MISSING_INJECTABLE_ANNOTATION = \"Missing required @injectable annotation in:\";\nexport const MISSING_INJECT_ANNOTATION = \"Missing required @inject or @multiInject annotation in:\";\nexport const CIRCULAR_DEPENDENCY = \"Circular dependency found between services:\";\nexport const NOT_IMPLEMENTED = \"Sorry, this feature is not fully implemented yet.\";\nexport const INVALID_BINDING_TYPE = \"Invalid binding type:\";\nexport const MISSING_EXPLICIT_CONSTRUCTOR = \"Derived class must explicitly declare its constructor:\";\nexport const INVALID_DECORATOR_OPERATION = \"The @inject @multiInject @tagged and @named decorators \" +\n    \"must be applied to the parameters of a constructor.\";\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\n// Used for named bindings\nexport const NAMED_TAG = \"named\";\n\n// The name of the target at design time\nexport const NAME_TAG = \"name\";\n\n// The type of the binding at design time\nexport const INJECT_TAG = \"inject\";\n\n// The type of the binding at design type for multi-injections\nexport const MULTI_INJECT_TAG = \"multi_inject\";\n\n// used to store tags\nexport const TAGGED = \"inversify:tagged\";\n\n// used to store types to be injected\nexport const PARAM_TYPES = \"inversify:paramtypes\";\n\n// used to access design time types\nexport const DESIGN_PARAM_TYPES = \"design:paramtypes\";\n","///<reference path=\"./interfaces/interfaces.d.ts\" />\n\n// Inversify\n// ---------\n\n// The Inversify main file, the library entry point.\n\nimport Kernel from \"./kernel/kernel\";\nimport injectable from \"./annotation/injectable\";\nimport tagged from \"./annotation/tagged\";\nimport named from \"./annotation/named\";\nimport inject from \"./annotation/inject\";\nimport multiInject from \"./annotation/multi_inject\";\nimport paramName from \"./annotation/param_name\";\nimport { decorate } from \"./annotation/decorator_utils\";\nimport { traverseAncerstors, taggedConstraint, namedConstraint, typeConstraint } from \"./syntax/constraint_helpers\";\n\nexport { Kernel };\nexport { decorate };\nexport { injectable };\nexport { tagged };\nexport { named };\nexport { inject };\nexport { multiInject };\nexport { paramName };\nexport { traverseAncerstors };\nexport { taggedConstraint };\nexport { namedConstraint };\nexport { typeConstraint };\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\n// Kernel\n// ------\n\n// Inversify is a lightweight pico container for TypeScript\n// and JavaScript apps.\n\n// A pico container uses a class constructor to identify and\n// inject its dependencies. For this to work, the class needs\n// to declare a constructor that includes everything it\n// needs injected.\n\n// In order to resolve a depencency, the pico container needs\n// to be told which implementation type (classes) to associate\n// with each service type (interfaces).\n\nimport BindingCount from \"../bindings/binding_count\";\nimport Binding from \"../bindings/binding\";\nimport Lookup from \"./lookup\";\nimport Planner from \"../planning/planner\";\nimport Resolver from \"../resolution/resolver\";\nimport * as ERROR_MSGS from \"../constants/error_msgs\";\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\nimport BindingToSyntax from \"../syntax/binding_to_syntax\";\nimport Metadata from \"../planning/metadata\";\nimport Target from \"../planning/target\";\nimport Request from \"../planning/request\";\n\nclass Kernel implements IKernel {\n\n    private _planner: IPlanner;\n    private _resolver: IResolver;\n    private _middleware: (context: IContext) => any;\n    private _bindingDictionary: ILookup<IBinding<any>>;\n\n    // Initialize private properties\n    public constructor() {\n        this._planner = new Planner();\n        this._resolver = new Resolver();\n        this._bindingDictionary = new Lookup<IBinding<any>>();\n        this._middleware = null;\n    }\n\n    public load(...modules: IKernelModule[]): void {\n        modules.forEach((module) => { module(this); });\n    }\n\n    public applyMiddleware(...middlewares: IMiddleware[]): void {\n        this._middleware = middlewares.reverse().reduce((prev, curr) => {\n            return curr(prev);\n        }, this._resolver.resolve.bind(this._resolver));\n    }\n\n    // Regiters a type binding\n    public bind<T>(serviceIdentifier: (string|Symbol|INewable<T>)): IBindingToSyntax<T> {\n        let binding = new Binding<T>(serviceIdentifier);\n        this._bindingDictionary.add(serviceIdentifier, binding);\n        return new BindingToSyntax<T>(binding);\n    }\n\n    // Removes a type binding from the registry by its key\n    public unbind(serviceIdentifier: (string|Symbol|any)): void {\n        try {\n            this._bindingDictionary.remove(serviceIdentifier);\n        } catch (e) {\n            throw new Error(`${ERROR_MSGS.CANNOT_UNBIND} ${serviceIdentifier}`);\n        }\n    }\n\n    // Removes all the type bindings from the registry\n    public unbindAll(): void {\n        this._bindingDictionary = new Lookup<IBinding<any>>();\n    }\n\n    // Resolves a dependency by its runtime identifier\n    // The runtime identifier must be associated with only one binding\n    // use getAll when the runtime identifier is associated with multiple bindings\n    public get<T>(serviceIdentifier: (string|Symbol|INewable<T>)): T {\n        return this._get<T>(serviceIdentifier, null);\n    }\n\n    public getNamed<T>(serviceIdentifier: (string|Symbol|INewable<T>), named: string): T {\n        return this.getTagged<T>(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);\n    }\n\n    public getTagged<T>(serviceIdentifier: (string|Symbol|INewable<T>), key: string, value: any): T {\n        let metadata = new Metadata(key, value);\n        let target = new Target(null, serviceIdentifier, metadata);\n        return this._get<T>(serviceIdentifier, target);\n    }\n\n    // Resolves a dependency by its runtime identifier\n    // The runtime identifier can be associated with one or multiple bindings\n    public getAll<T>(serviceIdentifier: (string|Symbol|INewable<T>)): T[] {\n\n        let bindings = this._planner.getBindings<T>(this, serviceIdentifier);\n\n        switch (bindings.length) {\n\n            // CASE 1: There are no bindings\n            case BindingCount.NoBindingsAvailable:\n                throw new Error(`${ERROR_MSGS.NOT_REGISTERED} ${serviceIdentifier}`);\n\n            // CASE 2: There is AT LEAST 1 binding    \n            case BindingCount.OnlyOneBindingAvailable:\n            case BindingCount.MultipleBindingsAvailable:\n            default:\n                return bindings.map((binding) => {\n                    return this._planAndResolve<T>(binding, null);\n                });\n        }\n    }\n\n    public getServiceIdentifierAsString(serviceIdentifier: (string|Symbol|INewable<any>)): string {\n        let type = typeof serviceIdentifier;\n        if (type === \"function\") {\n            let _serviceIdentifier: any = serviceIdentifier;\n            return _serviceIdentifier.name;\n        } else if (type === \"symbol\") {\n            return serviceIdentifier.toString();\n        } else { // string\n            let _serviceIdentifier: any = serviceIdentifier;\n            return _serviceIdentifier;\n        }\n    }\n\n    private _get<T>(serviceIdentifier: (string|Symbol|INewable<T>), target: ITarget): T {\n\n        let bindings = this._planner.getBindings<T>(this, serviceIdentifier);\n\n        // Filter bindings using the target and the binding constraints\n        if (target !== null) {\n\n            let request = new Request(\n                serviceIdentifier,\n                this._planner.createContext(this),\n                null,\n                bindings,\n                target\n            );\n\n            bindings = this._planner.getActiveBindings(request, target);\n        }\n\n        if (bindings.length === BindingCount.NoBindingsAvailable) {\n\n            // CASE 1: There are no bindings\n            throw new Error(`${ERROR_MSGS.NOT_REGISTERED} ${serviceIdentifier}`);\n\n        } else if (bindings.length === BindingCount.OnlyOneBindingAvailable) {\n\n            // CASE 2: There is 1 binding\n            return this._planAndResolve<T>(bindings[0], target);\n\n        } else {\n\n            // CASE 3: There are multiple bindings\n            throw new Error(`${ERROR_MSGS.AMBIGUOUS_MATCH} ${serviceIdentifier}`);\n\n        }\n\n    }\n\n    // Generates an executes a resolution plan\n    private _planAndResolve<T>(binding: IBinding<T>, target: ITarget): T {\n\n        // STEP 1: generate resolution context\n        let context = this._planner.createContext(this);\n\n        // STEP 2: generate a resolutioin plan & link it to the context\n        this._planner.createPlan(context, binding, target);\n\n        // STEP 3, 4 & 5: use middleware (optional), execute resolution plan & activation\n        return (this._middleware !== null) ? this._middleware(context) : this._resolver.resolve<T>(context);\n    }\n\n}\n\nexport default Kernel;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nclass KeyValuePair<T> implements IKeyValuePair<T> {\n\n    public serviceIdentifier: (string|Symbol|any);\n    public value: Array<T>;\n\n    public constructor(serviceIdentifier: (string|Symbol|any), value: T) {\n        this.serviceIdentifier = serviceIdentifier;\n        this.value = new Array<T>();\n        this.value.push(value);\n    }\n}\n\nexport default KeyValuePair;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\n// TypeBinding\n// -----------\n\n// A dictionary with support for duplicate keys\n\nimport KeyValuePair from \"./key_value_pair\";\nimport * as ERROR_MSGS from \"../constants/error_msgs\";\n\nclass Lookup<T> implements ILookup<T> {\n\n\t// dictionary used store multiple values for each key <key>\n    private _dictionary: Array<IKeyValuePair<T>>;\n\n    public constructor() {\n        this._dictionary = new Array<IKeyValuePair<T>>();\n    }\n\n\t// adds a new KeyValuePair to _dictionary\n    public add(serviceIdentifier: (string|Symbol|any), value: T): void {\n\n        if (serviceIdentifier === null || serviceIdentifier === undefined) { throw new Error(ERROR_MSGS.NULL_ARGUMENT); };\n        if (value === null || value === undefined) { throw new Error(ERROR_MSGS.NULL_ARGUMENT); };\n\n        let index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            this._dictionary[index].value.push(value);\n        } else {\n            this._dictionary.push(new KeyValuePair(serviceIdentifier, value));\n        }\n    }\n\n    // gets the value of a KeyValuePair by its serviceIdentifier\n    public get(serviceIdentifier: (string|Symbol|any)): Array<T> {\n\n        if (serviceIdentifier === null || serviceIdentifier === undefined) { throw new Error(ERROR_MSGS.NULL_ARGUMENT); }\n\n        let index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            return this._dictionary[index].value;\n        } else {\n            throw new Error(ERROR_MSGS.KEY_NOT_FOUND);\n        }\n    }\n\n\t// removes a KeyValuePair from _dictionary by its serviceIdentifier\n    public remove(serviceIdentifier: (string|Symbol|any)): void {\n\n        if (serviceIdentifier === null || serviceIdentifier === undefined) { throw new Error(ERROR_MSGS.NULL_ARGUMENT); }\n\n        let index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            this._dictionary.splice(index, 1);\n        } else {\n            throw new Error(ERROR_MSGS.KEY_NOT_FOUND);\n        }\n    }\n\n    // returns true if _dictionary contains serviceIdentifier\n    public hasKey(serviceIdentifier: (string|Symbol|any)): boolean {\n\n        if (serviceIdentifier === null || serviceIdentifier === undefined) { throw new Error(ERROR_MSGS.NULL_ARGUMENT); }\n\n        let index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n\t// finds the location of a KeyValuePair pair in _dictionary by its serviceIdentifier\n    private getIndexByKey(serviceIdentifier: (string|Symbol|any)): number {\n        let index = -1;\n        for (let i = 0; i < this._dictionary.length; i++) {\n            let keyValuePair = this._dictionary[i];\n            if (keyValuePair.serviceIdentifier === serviceIdentifier) {\n                index = i;\n            }\n        }\n        return index;\n    }\n\n}\n\nexport default Lookup;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nclass Context<TService> implements IContext {\n\n    public kernel: IKernel;\n    public plan: IPlan;\n\n    public constructor(kernel: IKernel) {\n        this.kernel = kernel;\n    }\n\n    public addPlan(plan: IPlan) {\n        this.plan = plan;\n    }\n}\n\nexport default Context;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nclass Metadata implements IMetadata {\n\n  public key: string;\n  public value: any;\n\n  constructor(key: string, value: any) {\n      this.key = key;\n      this.value = value;\n  }\n}\n\nexport default Metadata;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nclass Plan implements IPlan {\n\n    public parentContext: IContext;\n    public rootRequest: IRequest;\n\n    public constructor(parentContext: IContext, rootRequest: IRequest) {\n        this.parentContext = parentContext;\n        this.rootRequest = rootRequest;\n    }\n}\n\nexport default Plan;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport Plan from \"./plan\";\nimport Context from \"./context\";\nimport Request from \"./request\";\nimport Target from \"./target\";\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\nimport * as ERROR_MSGS from \"../constants/error_msgs\";\nimport BindingType from \"../bindings/binding_type\";\n\nclass Planner implements IPlanner {\n\n    public createContext(kernel: IKernel): IContext {\n        return new Context(kernel);\n    }\n\n    public createPlan(context: IContext, binding: IBinding<any>, target: ITarget): IPlan {\n\n        let rootRequest = new Request(\n            binding.serviceIdentifier,\n            context,\n            null,\n            binding,\n            target);\n\n        let plan = new Plan(context, rootRequest);\n\n        // Plan and Context are duable linked\n        context.addPlan(plan);\n\n        let dependencies = this._getDependencies(binding.implementationType);\n        dependencies.forEach((dependency) => { this._createSubRequest(rootRequest, dependency); });\n        return plan;\n    }\n\n    public getBindings<T>(kernel: IKernel, serviceIdentifier: (string|Symbol|INewable<T>)): IBinding<T>[] {\n        let bindings: IBinding<T>[] = [];\n        let _kernel: any = kernel;\n        let _bindingDictionary = _kernel._bindingDictionary;\n        if (_bindingDictionary.hasKey(serviceIdentifier)) {\n            bindings = _bindingDictionary.get(serviceIdentifier);\n        }\n        return bindings;\n    }\n\n    public getActiveBindings(parentRequest: IRequest, target: ITarget): IBinding<any>[] {\n\n        let bindings = this.getBindings<any>(parentRequest.parentContext.kernel, target.serviceIdentifier);\n        let activeBindings: IBinding<any>[] = [];\n\n        if (bindings.length > 1 && target.isArray() === false) {\n\n            // apply constraints if available to reduce the number of active bindings\n            activeBindings = bindings.filter((binding) => {\n\n                let request =  new Request(\n                    binding.serviceIdentifier,\n                    parentRequest.parentContext,\n                    parentRequest,\n                    binding,\n                    target\n                );\n\n                return binding.constraint(request);\n\n            });\n\n        } else {\n            activeBindings = bindings;\n        }\n\n        return activeBindings;\n    }\n\n    private _createSubRequest(parentRequest: IRequest, target: ITarget) {\n\n        try {\n            let activeBindings = this.getActiveBindings(parentRequest, target);\n\n            if (activeBindings.length === 0) {\n\n                // no matching bindings found\n                let serviceIdentifier = parentRequest.parentContext.kernel.getServiceIdentifierAsString(target.serviceIdentifier);\n                throw new Error(`${ERROR_MSGS.NOT_REGISTERED} ${serviceIdentifier}`);\n\n            } else if (activeBindings.length > 1 && target.isArray() === false) {\n\n                // more than one matching binding found but target is not an array\n                let serviceIdentifier = parentRequest.parentContext.kernel.getServiceIdentifierAsString(target.serviceIdentifier);\n                throw new Error(`${ERROR_MSGS.AMBIGUOUS_MATCH} ${serviceIdentifier}`);\n\n            } else {\n\n                // one ore more than one matching bindings found \n                // when more than 1 matching bindings found target is an array \n                this._createChildRequest(parentRequest, target, activeBindings);\n\n            }\n\n        } catch (error) {\n            if (error instanceof RangeError) {\n                this._throwWhenCircularDependenciesFound(parentRequest.parentContext.plan.rootRequest);\n            } else {\n                throw new Error(error.message);\n            }\n        }\n    }\n\n    private _createChildRequest(parentRequest: IRequest, target: ITarget, bindings: IBinding<any>[]) {\n\n        // Use the only active binding to create a child request\n        let childRequest = parentRequest.addChildRequest(target.serviceIdentifier, bindings, target);\n        let subChildRequest = childRequest;\n\n        bindings.forEach((binding) => {\n\n            if (target.isArray()) {\n                subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);\n            }\n\n            // Only try to plan sub-dependencies when binding type is BindingType.Instance\n            if (binding.type === BindingType.Instance) {\n\n                // Create child requests for sub-dependencies if any\n                let subDependencies = this._getDependencies(binding.implementationType);\n                subDependencies.forEach((d, index) => {\n                    this._createSubRequest(subChildRequest, d);\n                });\n            }\n\n        });\n    }\n\n    private _throwWhenCircularDependenciesFound(\n        request: IRequest, previousServiceIdentifiers: (string|Symbol|INewable<any>)[] = []\n    ) {\n\n        previousServiceIdentifiers.push(request.serviceIdentifier);\n\n        request.childRequests.forEach((childRequest) => {\n\n            let serviceIdentifier = childRequest.serviceIdentifier;\n            if (previousServiceIdentifiers.indexOf(serviceIdentifier) === -1) {\n                if (childRequest.childRequests.length > 0) {\n                    this._throwWhenCircularDependenciesFound(childRequest, previousServiceIdentifiers);\n                } else {\n                    previousServiceIdentifiers.push(serviceIdentifier);\n                }\n            } else {\n                let tailServiceIdentifier = request.parentContext.kernel.getServiceIdentifierAsString(request.serviceIdentifier);\n                throw new Error(`${ERROR_MSGS.CIRCULAR_DEPENDENCY} ${serviceIdentifier} and ${tailServiceIdentifier}`);\n            }\n\n        });\n    }\n\n    private _getDependencies(func: Function): ITarget[] {\n\n        if (func === null) { return []; }\n        let constructorName = (<any>func).name;\n\n        // TypeScript compiler generated annotations\n        let targetsTypes = Reflect.getMetadata(METADATA_KEY.PARAM_TYPES, func);\n\n        // All types resolved bust be annotated with @injectable\n        if (targetsTypes === undefined) {\n            let msg = `${ERROR_MSGS.MISSING_INJECTABLE_ANNOTATION} ${constructorName}.`;\n            throw new Error(msg);\n        }\n\n        // User generated annotations\n        let targetsMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED, func) || [];\n\n        let targets: ITarget[] = [];\n\n        for (let i = 0; i < func.length; i++) {\n\n            let targetType = targetsTypes[i];\n            // Create map from array of metadata for faster access to metadata\n            let targetMetadata = targetsMetadata[i.toString()] || [];\n            let targetMetadataMap: any = {};\n            targetMetadata.forEach((m: IMetadata) => {\n                targetMetadataMap[m.key.toString()] = m.value;\n            });\n\n            // user generated metadata\n            let inject: any = targetMetadataMap[METADATA_KEY.INJECT_TAG];\n            let multiInject: any = targetMetadataMap[METADATA_KEY.MULTI_INJECT_TAG];\n            let targetName: any = targetMetadataMap[METADATA_KEY.NAME_TAG];\n\n            // Take type to be injected from user-generated metadata \n            // if not available use compiler-generated metadata\n            targetType = (inject || multiInject) ? (inject || multiInject) : targetType;\n\n            // Types Object and Function are too ambiguous to be resolved\n            // user needs to generate metadata manually for those\n            if (targetType === Object || targetType === Function || targetType === undefined) {\n                let msg = `${ERROR_MSGS.MISSING_INJECT_ANNOTATION} argument ${i} in class ${constructorName}.`;\n                throw new Error(msg);\n            }\n\n            // Create target\n            let target = new Target(targetName, targetType);\n            target.metadata = targetMetadata;\n            targets.push(target);\n\n        }\n\n        // Throw if a derived class does not implement its constructor explicitly\n        // We do this to prevent errors when a base class (parent) has dependencies \n        // and one of the derived classes (children) has no dependencies\n        if (targets.length === 0 && this._baseClassHasDepencencies(func)) {\n            throw new Error(`${ERROR_MSGS.MISSING_EXPLICIT_CONSTRUCTOR} ${constructorName}.`);\n        }\n\n        return targets;\n    }\n\n    private _baseClassHasDepencencies(func: Function): boolean {\n        let baseConstructor = Object.getPrototypeOf(func.prototype).constructor;\n        if (baseConstructor !== Object) {\n            if (baseConstructor.length > 0) {\n                return true;\n            } else {\n                return this._baseClassHasDepencencies(baseConstructor);\n            }\n        } else {\n            return false;\n        }\n    }\n}\n\nexport default Planner;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nclass QueryableString implements IQueryableString {\n\n  private str: string;\n\n  constructor(str: string) {\n    this.str = str;\n  }\n\n  public startsWith(searchString: string): boolean {\n    return this.str.indexOf(searchString) === 0;\n  }\n\n  public endsWith(searchString: string): boolean {\n    let reverseString = \"\";\n    let reverseSearchString = searchString.split(\"\").reverse().join(\"\");\n    reverseString = this.str.split(\"\").reverse().join(\"\");\n    return this.startsWith.call({ str : reverseString }, reverseSearchString);\n  }\n\n  public contains(searchString: string): boolean {\n    return (this.str.indexOf(searchString) !== -1);\n  }\n\n  public equals(compareString: string): boolean {\n    return this.str === compareString;\n  }\n\n  public value(): string {\n    return this.str;\n  }\n\n}\n\nexport default QueryableString;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nclass Request implements IRequest {\n\n        public serviceIdentifier: (string|Symbol|INewable<any>);\n        public parentContext: IContext;\n        public parentRequest: IRequest;\n        public bindings: IBinding<any>[];\n        public childRequests: IRequest[];\n        public target: ITarget;\n\n        public constructor(\n            serviceIdentifier: (string|Symbol|INewable<any>),\n            parentContext: IContext,\n            parentRequest: IRequest,\n            bindings: (IBinding<any>|IBinding<any>[]),\n            target: ITarget = null) {\n\n                this.serviceIdentifier = serviceIdentifier;\n                this.parentContext = parentContext;\n                this.parentRequest = parentRequest;\n                this.target = target;\n                this.childRequests = [];\n                this.bindings = (Array.isArray(bindings) ? bindings : ((bindings) ? [bindings] : []));\n        }\n\n        public addChildRequest(\n            serviceIdentifier: string,\n            bindings: (IBinding<any>|IBinding<any>[]),\n            target: ITarget): IRequest {\n\n                let child = new Request(\n                    serviceIdentifier,\n                    this.parentContext,\n                    this,\n                    bindings,\n                    target\n                );\n                this.childRequests.push(child);\n                return child;\n        }\n}\n\nexport default Request;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport Metadata from \"../planning/metadata\";\nimport QueryableString from \"./queryable_string\";\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\n\nclass Target implements ITarget {\n\n  public serviceIdentifier: (string|Symbol|INewable<any>);\n  public name: QueryableString;\n  public metadata: Array<IMetadata>;\n\n  constructor(name: string, serviceIdentifier: (string|Symbol|INewable<any>), namedOrTagged?: (string|IMetadata)) {\n\n    this.serviceIdentifier = serviceIdentifier;\n    this.name = new QueryableString(name || \"\");\n    this.metadata = new Array<IMetadata>();\n    let metadataItem: IMetadata = null;\n\n    // is named target\n    if (typeof namedOrTagged === \"string\") {\n        metadataItem = new Metadata(METADATA_KEY.NAMED_TAG, namedOrTagged);\n    } else if (namedOrTagged instanceof Metadata) {\n        // is target with metadata\n        metadataItem = namedOrTagged;\n    }\n\n    // target has metadata\n    if (metadataItem !== null) {\n        this.metadata.push(metadataItem);\n    }\n  }\n\n  public hasTag(key: string): boolean {\n    for (let i = 0; i < this.metadata.length; i++) {\n      let m = this.metadata[i];\n      if (m.key === key) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public isArray(): boolean {\n      return this.hasTag(METADATA_KEY.MULTI_INJECT_TAG);\n  }\n\n  public matchesArray(name: string|Symbol|any): boolean {\n    return this.matchesTag(METADATA_KEY.MULTI_INJECT_TAG)(name);\n  }\n\n  public isNamed(): boolean {\n      return this.hasTag(METADATA_KEY.NAMED_TAG);\n  }\n\n  public isTagged(): boolean {\n    if (this.metadata.length > 1) {\n        return true;\n    } else if (this.metadata.length === 1) {\n        // NAMED_TAG is not considered a tagged binding\n        return !this.hasTag(METADATA_KEY.NAMED_TAG);\n    } else {\n        return false;\n    }\n  }\n\n  public matchesNamedTag(name: string): boolean {\n    return this.matchesTag(METADATA_KEY.NAMED_TAG)(name);\n  }\n\n  public matchesTag(key: string) {\n    return (value: any) => {\n        for (let i = 0; i < this.metadata.length; i++) {\n            let m = this.metadata[i];\n            if (m.key === key && m.value === value) {\n                return true;\n            }\n        }\n        return false;\n    };\n  }\n\n}\n\nexport default Target;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingScope from \"../bindings/binding_scope\";\nimport BindingType from \"../bindings/binding_type\";\nimport * as ERROR_MSGS from \"../constants/error_msgs\";\n\nclass Resolver implements IResolver {\n\n    public resolve<Service>(context: IContext): Service {\n        let rootRequest = context.plan.rootRequest;\n        return this._resolve(rootRequest);\n    }\n\n    private _resolve(request: IRequest): any {\n\n        let bindings = request.bindings;\n        let childRequests = request.childRequests;\n\n        if (\n            request.target && request.target.isArray() &&\n            (!request.parentRequest.target || !request.parentRequest.target.matchesArray(request.target.serviceIdentifier))\n        ) {\n\n            // Create an array instead of creating an instance\n            return childRequests.map((childRequest) => { return this._resolve(childRequest); });\n\n        } else {\n\n            let result: any = null;\n            let binding = bindings[0];\n            let isSingleton = binding.scope === BindingScope.Singleton;\n\n            if (isSingleton && binding.activated === true) {\n                return binding.cache;\n            }\n\n            switch (binding.type) {\n\n                case BindingType.Value:\n                    result = binding.cache;\n                    break;\n\n                case BindingType.Constructor:\n                    result = binding.implementationType;\n                    break;\n\n                case BindingType.Factory:\n                    result = binding.factory(request.parentContext);\n                    break;\n\n                case BindingType.Provider:\n                    result = binding.provider(request.parentContext);\n                    break;\n\n                case BindingType.Instance:\n\n                    let constr = binding.implementationType;\n\n                    if (childRequests.length > 0) {\n                        let injections = childRequests.map((childRequest) => {\n                            return this._resolve(childRequest);\n                        });\n\n                        result = this._createInstance(constr, injections);\n                    } else {\n                        result = new constr();\n                    }\n\n                    break;\n\n                case BindingType.Invalid:\n                default:\n                    // The user probably created a binding but didn't finish it\n                    // e.g. kernel.bind<T>(\"ISomething\"); missing BindingToSyntax\n                    let serviceIdentifier = request.parentContext.kernel.getServiceIdentifierAsString(request.serviceIdentifier);\n                    throw new Error(`${ERROR_MSGS.INVALID_BINDING_TYPE} ${serviceIdentifier}`);\n            }\n\n            // use activation handler if available\n            if (typeof binding.onActivation === \"function\") {\n                result = binding.onActivation(request.parentContext, result);\n            }\n\n            // store in cache if scope is singleton\n            if (isSingleton) {\n                binding.cache = result;\n                binding.activated = true;\n            }\n\n            return result;\n        }\n\n    }\n\n    private _createInstance(Func: { new(...args: any[]) : any }, injections: Object[]) {\n        return new Func(...injections);\n    }\n\n}\n\nexport default Resolver;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingScope from \"../bindings/binding_scope\";\nimport BindingWhenOnSyntax from \"./binding_when_on_syntax\";\n\nclass BindingInSyntax<T> implements IBindingInSyntax<T> {\n\n    private _binding: IBinding<T>;\n\n    public constructor(binding: IBinding<T>) {\n        this._binding = binding;\n    }\n\n    public inSingletonScope(): IBindingWhenOnSyntax<T> {\n        this._binding.scope = BindingScope.Singleton;\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n}\n\nexport default BindingInSyntax;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingInSyntax from \"./binding_in_syntax\";\nimport BindingWhenSyntax from \"./binding_when_syntax\";\nimport BindingOnSyntax from \"./binding_on_syntax\";\n\nclass BindingInWhenOnSyntax<T> implements IBindingInSyntax<T>, IBindingWhenSyntax<T>, IBindingOnSyntax<T>  {\n\n    private _bindingInSyntax: BindingInSyntax<T>;\n    private _bindingWhenSyntax: IBindingWhenSyntax<T>;\n    private _bindingOnSyntax: IBindingOnSyntax<T>;\n    private _binding: IBinding<T>;\n\n    public constructor(binding: IBinding<T>) {\n        this._binding = binding;\n        this._bindingWhenSyntax = new BindingWhenSyntax<T>(this._binding);\n        this._bindingOnSyntax = new BindingOnSyntax<T>(this._binding);\n        this._bindingInSyntax = new BindingInSyntax<T>(binding);\n    }\n\n    public inSingletonScope(): IBindingWhenOnSyntax<T> {\n        return this._bindingInSyntax.inSingletonScope();\n    }\n\n    public when(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.when(constraint);\n    }\n\n    public whenTargetNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenTargetNamed(name);\n    }\n\n    public whenTargetTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenTargetTagged(tag, value);\n    }\n\n    public whenInjectedInto(parent: (Function|string)): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenInjectedInto(parent);\n    }\n\n    public whenParentNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenParentNamed(name);\n    }\n\n    public whenParentTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenParentTagged(tag, value);\n    }\n\n    public whenAnyAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);\n    }\n\n    public whenNoAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);\n    }\n\n    public whenAnyAncestorNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);\n    }\n\n    public whenAnyAncestorTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);\n    }\n\n    public whenNoAncestorNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorNamed(name);\n    }\n\n    public whenNoAncestorTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);\n    }\n\n    public whenAnyAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);\n    }\n\n    public whenNoAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);\n    }\n\n    public onActivation(handler: (context: IContext, injectable: T) => T): IBindingWhenSyntax<T> {\n        return this._bindingOnSyntax.onActivation(handler);\n    }\n\n}\n\nexport default BindingInWhenOnSyntax;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingWhenSyntax from \"./binding_when_syntax\";\n\nclass BindingOnSyntax<T> implements IBindingOnSyntax<T> {\n\n    private _binding: IBinding<T>;\n\n    public constructor(binding: IBinding<T>) {\n        this._binding = binding;\n    }\n\n    public onActivation(handler: (context: IContext, injectable: T) => T): IBindingWhenSyntax<T> {\n        this._binding.onActivation = handler;\n        return new BindingWhenSyntax<T>(this._binding);\n    }\n\n}\n\nexport default BindingOnSyntax;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingInWhenOnSyntax from \"./binding_in_when_on_syntax\";\nimport BindingWhenOnSyntax from \"./binding_when_on_syntax\";\nimport BindingType from \"../bindings/binding_type\";\n\nclass BindingToSyntax<T> implements IBindingToSyntax<T> {\n\n    private _binding: IBinding<T>;\n\n    public constructor(binding: IBinding<T>) {\n        this._binding = binding;\n    }\n\n    public to(constructor: { new(...args: any[]): T; }): IBindingInWhenOnSyntax<T> {\n        this._binding.type = BindingType.Instance;\n        this._binding.implementationType = constructor;\n        return new BindingInWhenOnSyntax<T>(this._binding);\n    }\n\n    public toValue(value: T): IBindingWhenOnSyntax<T> {\n        this._binding.type = BindingType.Value;\n        this._binding.cache = value;\n        this._binding.implementationType = null;\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n    public toConstructor<T2>(constructor: INewable<T2>): IBindingWhenOnSyntax<T> {\n        this._binding.type = BindingType.Constructor;\n        this._binding.implementationType = <any>constructor;\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n    public toFactory<T2>(factory: IFactoryCreator<T2>): IBindingWhenOnSyntax<T> {\n        this._binding.type = BindingType.Factory;\n        this._binding.factory = <any>factory;\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n    public toAutoFactory<T2>(serviceIdentifier: (string|Symbol|INewable<T2>)): IBindingWhenOnSyntax<T> {\n        this._binding.type = BindingType.Factory;\n        this._binding.factory = (context) => {\n            return () => {\n                return context.kernel.get<T2>(serviceIdentifier);\n            };\n        };\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n    public toProvider<T2>(provider: IProviderCreator<T2>): IBindingWhenOnSyntax<T> {\n        this._binding.type = BindingType.Provider;\n        this._binding.provider = <any>provider;\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n}\n\nexport default BindingToSyntax;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingWhenSyntax from \"./binding_when_syntax\";\nimport BindingOnSyntax from \"./binding_on_syntax\";\n\nclass BindingWhenOnSyntax<T> implements IBindingWhenSyntax<T>, IBindingOnSyntax<T> {\n\n    private _bindingWhenSyntax: IBindingWhenSyntax<T>;\n    private _bindingOnSyntax: IBindingOnSyntax<T>;\n    private _binding: IBinding<T>;\n\n    public constructor(binding: IBinding<T>) {\n        this._binding = binding;\n        this._bindingWhenSyntax = new BindingWhenSyntax<T>(this._binding);\n        this._bindingOnSyntax = new BindingOnSyntax<T>(this._binding);\n    }\n\n    public when(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.when(constraint);\n    }\n\n    public whenTargetNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenTargetNamed(name);\n    }\n\n    public whenTargetTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenTargetTagged(tag, value);\n    }\n\n    public whenInjectedInto(parent: (Function|string)): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenInjectedInto(parent);\n    }\n\n    public whenParentNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenParentNamed(name);\n    }\n\n    public whenParentTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenParentTagged(tag, value);\n    }\n\n    public whenAnyAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);\n    }\n\n    public whenNoAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);\n    }\n\n    public whenAnyAncestorNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);\n    }\n\n    public whenAnyAncestorTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);\n    }\n\n    public whenNoAncestorNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorNamed(name);\n    }\n\n    public whenNoAncestorTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);\n    }\n\n    public whenAnyAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);\n    }\n\n    public whenNoAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);\n    }\n\n    public onActivation(handler: (context: IContext, injectable: T) => T): IBindingWhenSyntax<T> {\n        return this._bindingOnSyntax.onActivation(handler);\n    }\n\n}\n\nexport default BindingWhenOnSyntax;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingOnSyntax from \"./binding_on_syntax\";\nimport { traverseAncerstors, taggedConstraint, namedConstraint, typeConstraint } from \"./constraint_helpers\";\n\nclass BindingWhenSyntax<T> implements IBindingWhenSyntax<T> {\n\n    private _binding: IBinding<T>;\n\n    public constructor(binding: IBinding<T>) {\n        this._binding = binding;\n    }\n\n    public when(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        this._binding.constraint = constraint;\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenTargetNamed(name: string): IBindingOnSyntax<T> {\n        this._binding.constraint = namedConstraint(name);\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenTargetTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        this._binding.constraint = taggedConstraint(tag)(value);\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenInjectedInto(parent: (Function|string)): IBindingOnSyntax<T> {\n        this._binding.constraint = (request: IRequest) => {\n            return typeConstraint(parent)(request.parentRequest);\n        };\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenParentNamed(name: string): IBindingOnSyntax<T> {\n        this._binding.constraint = (request: IRequest) => {\n            return namedConstraint(name)(request.parentRequest);\n        };\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenParentTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        this._binding.constraint = (request: IRequest) => {\n            return taggedConstraint(tag)(value)(request.parentRequest);\n        };\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenAnyAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T> {\n        this._binding.constraint = (request: IRequest) => {\n            return traverseAncerstors(request, typeConstraint(ancestor));\n        };\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenNoAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T> {\n        this._binding.constraint = (request: IRequest) => {\n            return !traverseAncerstors(request, typeConstraint(ancestor));\n        };\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenAnyAncestorNamed(name: string): IBindingOnSyntax<T> {\n\n        this._binding.constraint = (request: IRequest) => {\n            return traverseAncerstors(request, namedConstraint(name));\n        };\n\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenNoAncestorNamed(name: string): IBindingOnSyntax<T> {\n\n        this._binding.constraint = (request: IRequest) => {\n            return !traverseAncerstors(request, namedConstraint(name));\n        };\n\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenAnyAncestorTagged(tag: string, value: any): IBindingOnSyntax<T> {\n\n        this._binding.constraint = (request: IRequest) => {\n            return traverseAncerstors(request, taggedConstraint(tag)(value));\n        };\n\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenNoAncestorTagged(tag: string, value: any): IBindingOnSyntax<T> {\n\n        this._binding.constraint = (request: IRequest) => {\n            return !traverseAncerstors(request, taggedConstraint(tag)(value));\n        };\n\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenAnyAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n\n        this._binding.constraint = (request: IRequest) => {\n            return traverseAncerstors(request, constraint);\n        };\n\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenNoAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n\n        this._binding.constraint = (request: IRequest) => {\n            return !traverseAncerstors(request, constraint);\n        };\n\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n}\n\nexport default BindingWhenSyntax;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\n\nlet traverseAncerstors = (request: IRequest, constraint: (request: IRequest) => boolean): boolean => {\n    let parent = request.parentRequest;\n    if (parent !== null) {\n        return constraint(parent) ? true : traverseAncerstors(parent, constraint);\n    } else {\n        return false;\n    }\n};\n\n// This helpers use currying to help you to generate constraints\n\nlet taggedConstraint = (key: string) => (value: any) => (request: IRequest) => {\n    return request.target.matchesTag(key)(value);\n};\n\nlet namedConstraint = taggedConstraint(METADATA_KEY.NAMED_TAG);\n\nlet typeConstraint = (type: (Function|string)) => (request: IRequest) => {\n\n    // Using index 0 because constraints are applied \n    // to one binding at a time (see Planner class)\n    let binding = request.bindings[0];\n\n    if (typeof type === \"string\") {\n        let serviceIdentifier = binding.serviceIdentifier;\n        return serviceIdentifier === type;\n    } else {\n        let constructor = request.bindings[0].implementationType;\n        return type === constructor;\n    }\n};\n\nexport { traverseAncerstors, taggedConstraint, namedConstraint, typeConstraint };\n"],"sourceRoot":"/source/"}