{"version":3,"sources":["node_modules/browser-pack/_prelude.js","inversify.min.js","src/annotation/decorator_utils.ts","src/annotation/inject.ts","src/annotation/injectable.ts","src/annotation/multi_inject.ts","src/annotation/named.ts","src/annotation/property_injectors.ts","src/annotation/tagged.ts","src/annotation/target_name.ts","src/bindings/binding.ts","src/bindings/binding_count.ts","src/bindings/binding_scope.ts","src/bindings/binding_type.ts","src/constants/error_msgs.ts","src/constants/metadata_keys.ts","src/inversify.ts","src/kernel/kernel.ts","src/kernel/kernel_snapshot.ts","src/kernel/key_value_pair.ts","src/kernel/lookup.ts","src/planning/context.ts","src/planning/metadata.ts","src/planning/plan.ts","src/planning/planner.ts","src/planning/queryable_string.ts","src/planning/request.ts","src/planning/target.ts","src/resolution/resolver.ts","src/syntax/binding_in_syntax.ts","src/syntax/binding_in_when_on_syntax.ts","src/syntax/binding_on_syntax.ts","src/syntax/binding_to_syntax.ts","src/syntax/binding_when_on_syntax.ts","src/syntax/binding_when_syntax.ts","src/syntax/constraint_helpers.ts"],"names":["f","exports","module","define","amd","g","window","global","self","this","inversify","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","tagParameter","annotationTarget","propertyName","parameterIndex","metadata","metadataKey","METADATA_KEY","TAGGED","_tagParameterOrProperty","tagProperty","TAGGED_PROP","constructor","paramsOrPropertiesMetadata","isParameterDecorator","key","toString","undefined","ERROR_MSGS","INVALID_DECORATOR_OPERATION","Reflect","hasOwnMetadata","getMetadata","paramOrPropertyMetadata","Array","isArray","m","DUPLICATED_METADATA","push","defineMetadata","_decorate","decorators","target","decorate","_param","paramIndex","decorator","../constants/error_msgs","../constants/metadata_keys","2","inject","serviceIdentifier","targetKey","index","metadata_1","INJECT_TAG","decorator_utils_1","Object","defineProperty","value","../planning/metadata","./decorator_utils","3","injectable","PARAM_TYPES","ERRORS_MSGS","DUPLICATED_INJECTABLE_DECORATOR","types","DESIGN_PARAM_TYPES","4","multiInject","MULTI_INJECT_TAG","5","named","name","NAMED_TAG","6","_proxyGetter","proto","resolve","getter","hasMetadata","INJECTION","setter","newVal","configurable","enumerable","get","set","makePropertyInjectDecorator","kernel","makePropertyInjectNamedDecorator","getNamed","makePropertyInjectTaggedDecorator","getTagged","makePropertyMultiInjectDecorator","getAll","Symbol","7","tagged","metadataValue","8","targetName","NAME_TAG","9","binding_scope_1","binding_type_1","Binding","activated","scope","Transient","type","Invalid","constraint","request","implementationType","cache","factory","provider","onActivation","./binding_scope","./binding_type","10","BindingCount","11","BindingScope","12","BindingType","13","NULL_ARGUMENT","KEY_NOT_FOUND","AMBIGUOUS_MATCH","CANNOT_UNBIND","NOT_REGISTERED","MISSING_INJECTABLE_ANNOTATION","MISSING_INJECT_ANNOTATION","CIRCULAR_DEPENDENCY","NOT_IMPLEMENTED","INVALID_BINDING_TYPE","MISSING_EXPLICIT_CONSTRUCTOR","NO_MORE_SNAPSHOTS_AVAILABLE","14","15","kernel_1","Kernel","injectable_1","tagged_1","named_1","inject_1","property_injectors_1","multi_inject_1","target_name_1","constraint_helpers_1","traverseAncerstors","taggedConstraint","namedConstraint","typeConstraint","./annotation/decorator_utils","./annotation/inject","./annotation/injectable","./annotation/multi_inject","./annotation/named","./annotation/property_injectors","./annotation/tagged","./annotation/target_name","./kernel/kernel","./syntax/constraint_helpers","16","binding_count_1","binding_1","lookup_1","planner_1","resolver_1","binding_to_syntax_1","target_1","request_1","kernel_snapshot_1","_planner","_resolver","_bindingDictionary","_middleware","_snapshots","prototype","load","_this","modules","_i","arguments","forEach","applyMiddleware","middlewares","reverse","reduce","prev","curr","bind","binding","add","unbind","remove","unbindAll","_get","bindings","getBindings","NoBindingsAvailable","OnlyOneBindingAvailable","MultipleBindingsAvailable","map","_planAndResolve","getServiceIdentifierAsString","_serviceIdentifier","snapshot","of","clone","restore","pop","middleware","createContext","getActiveBindings","context","createPlan","../bindings/binding","../bindings/binding_count","../planning/planner","../planning/request","../planning/target","../resolution/resolver","../syntax/binding_to_syntax","./kernel_snapshot","./lookup","17","KernelSnapshot","18","KeyValuePair","19","key_value_pair_1","Lookup","_dictionary","getIndexByKey","splice","hasKey","_a","entry","_b","_c","keyValuePair","./key_value_pair","20","Context","addPlan","plan","21","Metadata","22","Plan","parentContext","rootRequest","23","plan_1","context_1","Planner","dependencies","_getDependencies","dependency","_createSubRequest","_kernel","parentRequest","activeBindings","filter","_createChildRequest","error","RangeError","message","_throwWhenCircularDependenciesFound","childRequest","addChildRequest","subChildRequest","Instance","subDependencies","d","previousServiceIdentifiers","childRequests","indexOf","tailServiceIdentifier","func","constructorName","targetsTypes","msg","targetsMetadata","targets","_loop_1","targetType","targetMetadata","targetMetadataMap","Function","_baseClassHasDepencencies","baseConstructor","getPrototypeOf","../bindings/binding_type","./context","./plan","./request","./target","24","QueryableString","str","startsWith","searchString","endsWith","reverseString","reverseSearchString","split","join","contains","equals","compareString","25","Request","child","26","queryable_string_1","Target","namedOrTagged","metadataItem","hasTag","matchesArray","matchesTag","isNamed","isTagged","matchesNamedTag","./queryable_string","27","Resolver","_resolve","result","isSingleton","Singleton","ConstantValue","DynamicValue","dynamicValue","Constructor","Factory","Provider","constr","injections","_createInstance","Func","apply","concat","../bindings/binding_scope","28","binding_when_on_syntax_1","BindingInSyntax","_binding","inSingletonScope","./binding_when_on_syntax","29","binding_in_syntax_1","binding_when_syntax_1","binding_on_syntax_1","BindingInWhenOnSyntax","_bindingWhenSyntax","_bindingOnSyntax","_bindingInSyntax","when","whenTargetNamed","whenTargetTagged","tag","whenInjectedInto","parent","whenParentNamed","whenParentTagged","whenAnyAncestorIs","ancestor","whenNoAncestorIs","whenAnyAncestorNamed","whenAnyAncestorTagged","whenNoAncestorNamed","whenNoAncestorTagged","whenAnyAncestorMatches","whenNoAncestorMatches","handler","./binding_in_syntax","./binding_on_syntax","./binding_when_syntax","30","BindingOnSyntax","31","binding_in_when_on_syntax_1","BindingToSyntax","to","toConstantValue","toDynamicValue","toConstructor","toFactory","toAutoFactory","toProvider","./binding_in_when_on_syntax","32","BindingWhenOnSyntax","33","BindingWhenSyntax","./constraint_helpers","34"],"mappings":"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","file":"inversify.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.inversify = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nvar ERROR_MSGS = require(\"../constants/error_msgs\");\nfunction tagParameter(annotationTarget, propertyName, parameterIndex, metadata) {\n    var metadataKey = METADATA_KEY.TAGGED;\n    return _tagParameterOrProperty(metadataKey, annotationTarget, propertyName, metadata, parameterIndex);\n}\nexports.tagParameter = tagParameter;\nfunction tagProperty(annotationTarget, propertyName, metadata) {\n    var metadataKey = METADATA_KEY.TAGGED_PROP;\n    return _tagParameterOrProperty(metadataKey, annotationTarget.constructor, propertyName, metadata);\n}\nexports.tagProperty = tagProperty;\nfunction _tagParameterOrProperty(metadataKey, annotationTarget, propertyName, metadata, parameterIndex) {\n    var paramsOrPropertiesMetadata = null;\n    var isParameterDecorator = (typeof parameterIndex === \"number\");\n    var key = (isParameterDecorator) ? parameterIndex.toString() : propertyName;\n    if (isParameterDecorator === true && propertyName !== undefined) {\n        throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);\n    }\n    if (Reflect.hasOwnMetadata(metadataKey, annotationTarget) !== true) {\n        paramsOrPropertiesMetadata = {};\n    }\n    else {\n        paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);\n    }\n    var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];\n    if (Array.isArray(paramOrPropertyMetadata) !== true) {\n        paramOrPropertyMetadata = [];\n    }\n    else {\n        for (var i = 0; i < paramOrPropertyMetadata.length; i++) {\n            var m = paramOrPropertyMetadata[i];\n            if (m.key === metadata.key) {\n                throw new Error(ERROR_MSGS.DUPLICATED_METADATA + \" \" + m.key);\n            }\n        }\n    }\n    paramOrPropertyMetadata.push(metadata);\n    paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;\n    Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);\n    return annotationTarget;\n}\nfunction _decorate(decorators, target) {\n    Reflect.decorate(decorators, target);\n}\nfunction _param(paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); };\n}\nfunction decorate(decorator, target, parameterIndex) {\n    if (typeof parameterIndex === \"number\") {\n        _decorate([_param(parameterIndex, decorator)], target);\n    }\n    else {\n        _decorate([decorator], target);\n    }\n}\nexports.decorate = decorate;\n\n},{\"../constants/error_msgs\":13,\"../constants/metadata_keys\":14}],2:[function(require,module,exports){\n\"use strict\";\nvar metadata_1 = require(\"../planning/metadata\");\nvar decorator_utils_1 = require(\"./decorator_utils\");\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nfunction inject(serviceIdentifier) {\n    return function (target, targetKey, index) {\n        var metadata = new metadata_1.default(METADATA_KEY.INJECT_TAG, serviceIdentifier);\n        return decorator_utils_1.tagParameter(target, targetKey, index, metadata);\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = inject;\n\n},{\"../constants/metadata_keys\":14,\"../planning/metadata\":21,\"./decorator_utils\":1}],3:[function(require,module,exports){\n\"use strict\";\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nvar ERRORS_MSGS = require(\"../constants/error_msgs\");\nfunction injectable() {\n    return function (target) {\n        if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target) === true) {\n            throw new Error(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);\n        }\n        var types = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, target) || [];\n        Reflect.defineMetadata(METADATA_KEY.PARAM_TYPES, types, target);\n        return target;\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = injectable;\n\n},{\"../constants/error_msgs\":13,\"../constants/metadata_keys\":14}],4:[function(require,module,exports){\n\"use strict\";\nvar metadata_1 = require(\"../planning/metadata\");\nvar decorator_utils_1 = require(\"./decorator_utils\");\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nfunction multiInject(serviceIdentifier) {\n    return function (target, targetKey, index) {\n        var metadata = new metadata_1.default(METADATA_KEY.MULTI_INJECT_TAG, serviceIdentifier);\n        return decorator_utils_1.tagParameter(target, targetKey, index, metadata);\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = multiInject;\n\n},{\"../constants/metadata_keys\":14,\"../planning/metadata\":21,\"./decorator_utils\":1}],5:[function(require,module,exports){\n\"use strict\";\nvar metadata_1 = require(\"../planning/metadata\");\nvar decorator_utils_1 = require(\"./decorator_utils\");\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nfunction named(name) {\n    return function (target, targetKey, index) {\n        var metadata = new metadata_1.default(METADATA_KEY.NAMED_TAG, name);\n        if (typeof index === \"number\") {\n            return decorator_utils_1.tagParameter(target, targetKey, index, metadata);\n        }\n        else {\n            return decorator_utils_1.tagProperty(target, targetKey, metadata);\n        }\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = named;\n\n},{\"../constants/metadata_keys\":14,\"../planning/metadata\":21,\"./decorator_utils\":1}],6:[function(require,module,exports){\n\"use strict\";\nvar INJECTION = Symbol();\nfunction _proxyGetter(proto, key, resolve) {\n    function getter() {\n        if (!Reflect.hasMetadata(INJECTION, this, key)) {\n            Reflect.defineMetadata(INJECTION, resolve(), this, key);\n        }\n        return Reflect.getMetadata(INJECTION, this, key);\n    }\n    function setter(newVal) {\n        Reflect.defineMetadata(INJECTION, newVal, this, key);\n    }\n    Object.defineProperty(proto, key, {\n        configurable: true,\n        enumerable: true,\n        get: getter,\n        set: setter\n    });\n}\nfunction makePropertyInjectDecorator(kernel) {\n    return function (serviceIdentifier) {\n        return function (proto, key) {\n            var resolve = function () {\n                return kernel.get(serviceIdentifier);\n            };\n            _proxyGetter(proto, key, resolve);\n        };\n    };\n}\nexports.makePropertyInjectDecorator = makePropertyInjectDecorator;\nfunction makePropertyInjectNamedDecorator(kernel) {\n    return function (serviceIdentifier, named) {\n        return function (proto, key) {\n            var resolve = function () {\n                return kernel.getNamed(serviceIdentifier, named);\n            };\n            _proxyGetter(proto, key, resolve);\n        };\n    };\n}\nexports.makePropertyInjectNamedDecorator = makePropertyInjectNamedDecorator;\nfunction makePropertyInjectTaggedDecorator(kernel) {\n    return function (serviceIdentifier, key, value) {\n        return function (proto, propertyName) {\n            var resolve = function () {\n                return kernel.getTagged(serviceIdentifier, key, value);\n            };\n            _proxyGetter(proto, propertyName, resolve);\n        };\n    };\n}\nexports.makePropertyInjectTaggedDecorator = makePropertyInjectTaggedDecorator;\nfunction makePropertyMultiInjectDecorator(kernel) {\n    return function (serviceIdentifier) {\n        return function (proto, key) {\n            var resolve = function () {\n                return kernel.getAll(serviceIdentifier);\n            };\n            _proxyGetter(proto, key, resolve);\n        };\n    };\n}\nexports.makePropertyMultiInjectDecorator = makePropertyMultiInjectDecorator;\n\n},{}],7:[function(require,module,exports){\n\"use strict\";\nvar metadata_1 = require(\"../planning/metadata\");\nvar decorator_utils_1 = require(\"./decorator_utils\");\nfunction tagged(metadataKey, metadataValue) {\n    return function (target, targetKey, index) {\n        var metadata = new metadata_1.default(metadataKey, metadataValue);\n        if (typeof index === \"number\") {\n            return decorator_utils_1.tagParameter(target, targetKey, index, metadata);\n        }\n        else {\n            return decorator_utils_1.tagProperty(target, targetKey, metadata);\n        }\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = tagged;\n\n},{\"../planning/metadata\":21,\"./decorator_utils\":1}],8:[function(require,module,exports){\n\"use strict\";\nvar metadata_1 = require(\"../planning/metadata\");\nvar decorator_utils_1 = require(\"./decorator_utils\");\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nfunction targetName(name) {\n    return function (target, targetKey, index) {\n        var metadata = new metadata_1.default(METADATA_KEY.NAME_TAG, name);\n        return decorator_utils_1.tagParameter(target, targetKey, index, metadata);\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = targetName;\n\n},{\"../constants/metadata_keys\":14,\"../planning/metadata\":21,\"./decorator_utils\":1}],9:[function(require,module,exports){\n\"use strict\";\nvar binding_scope_1 = require(\"./binding_scope\");\nvar binding_type_1 = require(\"./binding_type\");\nvar Binding = (function () {\n    function Binding(serviceIdentifier) {\n        this.activated = false;\n        this.serviceIdentifier = serviceIdentifier;\n        this.scope = binding_scope_1.default.Transient;\n        this.type = binding_type_1.default.Invalid;\n        this.constraint = function (request) { return true; };\n        this.implementationType = null;\n        this.cache = null;\n        this.factory = null;\n        this.provider = null;\n        this.onActivation = null;\n    }\n    return Binding;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Binding;\n\n},{\"./binding_scope\":11,\"./binding_type\":12}],10:[function(require,module,exports){\n\"use strict\";\nvar BindingCount;\n(function (BindingCount) {\n    BindingCount[BindingCount[\"NoBindingsAvailable\"] = 0] = \"NoBindingsAvailable\";\n    BindingCount[BindingCount[\"OnlyOneBindingAvailable\"] = 1] = \"OnlyOneBindingAvailable\";\n    BindingCount[BindingCount[\"MultipleBindingsAvailable\"] = 2] = \"MultipleBindingsAvailable\";\n})(BindingCount || (BindingCount = {}));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BindingCount;\n\n},{}],11:[function(require,module,exports){\n\"use strict\";\nvar BindingScope;\n(function (BindingScope) {\n    BindingScope[BindingScope[\"Transient\"] = 0] = \"Transient\";\n    BindingScope[BindingScope[\"Singleton\"] = 1] = \"Singleton\";\n})(BindingScope || (BindingScope = {}));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BindingScope;\n\n},{}],12:[function(require,module,exports){\n\"use strict\";\nvar BindingType;\n(function (BindingType) {\n    BindingType[BindingType[\"Invalid\"] = 0] = \"Invalid\";\n    BindingType[BindingType[\"Instance\"] = 1] = \"Instance\";\n    BindingType[BindingType[\"ConstantValue\"] = 2] = \"ConstantValue\";\n    BindingType[BindingType[\"DynamicValue\"] = 3] = \"DynamicValue\";\n    BindingType[BindingType[\"Constructor\"] = 4] = \"Constructor\";\n    BindingType[BindingType[\"Factory\"] = 5] = \"Factory\";\n    BindingType[BindingType[\"Provider\"] = 6] = \"Provider\";\n})(BindingType || (BindingType = {}));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BindingType;\n\n},{}],13:[function(require,module,exports){\n\"use strict\";\nexports.DUPLICATED_INJECTABLE_DECORATOR = \"Cannot apply @injectable decorator multiple times.\";\nexports.DUPLICATED_METADATA = \"Metadadata key was used more than once in a parameter:\";\nexports.NULL_ARGUMENT = \"NULL argument\";\nexports.KEY_NOT_FOUND = \"Key Not Found\";\nexports.AMBIGUOUS_MATCH = \"Ambiguous match found for serviceIdentifier:\";\nexports.CANNOT_UNBIND = \"Could not unbind serviceIdentifier:\";\nexports.NOT_REGISTERED = \"No bindings found for serviceIdentifier:\";\nexports.MISSING_INJECTABLE_ANNOTATION = \"Missing required @injectable annotation in:\";\nexports.MISSING_INJECT_ANNOTATION = \"Missing required @inject or @multiInject annotation in:\";\nexports.CIRCULAR_DEPENDENCY = \"Circular dependency found between services:\";\nexports.NOT_IMPLEMENTED = \"Sorry, this feature is not fully implemented yet.\";\nexports.INVALID_BINDING_TYPE = \"Invalid binding type:\";\nexports.MISSING_EXPLICIT_CONSTRUCTOR = \"Derived class must explicitly declare its constructor:\";\nexports.INVALID_DECORATOR_OPERATION = \"The @inject @multiInject @tagged and @named decorators \" +\n    \"must be applied to the parameters of a class constructor or a class property.\";\nexports.NO_MORE_SNAPSHOTS_AVAILABLE = \"No snapshot available to restore.\";\n\n},{}],14:[function(require,module,exports){\n\"use strict\";\nexports.NAMED_TAG = \"named\";\nexports.NAME_TAG = \"name\";\nexports.INJECT_TAG = \"inject\";\nexports.MULTI_INJECT_TAG = \"multi_inject\";\nexports.TAGGED = \"inversify:tagged\";\nexports.TAGGED_PROP = \"inversify:tagged_props\";\nexports.PARAM_TYPES = \"inversify:paramtypes\";\nexports.DESIGN_PARAM_TYPES = \"design:paramtypes\";\n\n},{}],15:[function(require,module,exports){\n\"use strict\";\nvar kernel_1 = require(\"./kernel/kernel\");\nexports.Kernel = kernel_1.default;\nvar injectable_1 = require(\"./annotation/injectable\");\nexports.injectable = injectable_1.default;\nvar tagged_1 = require(\"./annotation/tagged\");\nexports.tagged = tagged_1.default;\nvar named_1 = require(\"./annotation/named\");\nexports.named = named_1.default;\nvar inject_1 = require(\"./annotation/inject\");\nexports.inject = inject_1.default;\nvar property_injectors_1 = require(\"./annotation/property_injectors\");\nexports.makePropertyInjectDecorator = property_injectors_1.makePropertyInjectDecorator;\nexports.makePropertyMultiInjectDecorator = property_injectors_1.makePropertyMultiInjectDecorator;\nvar multi_inject_1 = require(\"./annotation/multi_inject\");\nexports.multiInject = multi_inject_1.default;\nvar target_name_1 = require(\"./annotation/target_name\");\nexports.targetName = target_name_1.default;\nvar decorator_utils_1 = require(\"./annotation/decorator_utils\");\nexports.decorate = decorator_utils_1.decorate;\nvar constraint_helpers_1 = require(\"./syntax/constraint_helpers\");\nexports.traverseAncerstors = constraint_helpers_1.traverseAncerstors;\nexports.taggedConstraint = constraint_helpers_1.taggedConstraint;\nexports.namedConstraint = constraint_helpers_1.namedConstraint;\nexports.typeConstraint = constraint_helpers_1.typeConstraint;\n\n},{\"./annotation/decorator_utils\":1,\"./annotation/inject\":2,\"./annotation/injectable\":3,\"./annotation/multi_inject\":4,\"./annotation/named\":5,\"./annotation/property_injectors\":6,\"./annotation/tagged\":7,\"./annotation/target_name\":8,\"./kernel/kernel\":16,\"./syntax/constraint_helpers\":34}],16:[function(require,module,exports){\n\"use strict\";\nvar binding_count_1 = require(\"../bindings/binding_count\");\nvar binding_1 = require(\"../bindings/binding\");\nvar lookup_1 = require(\"./lookup\");\nvar planner_1 = require(\"../planning/planner\");\nvar resolver_1 = require(\"../resolution/resolver\");\nvar ERROR_MSGS = require(\"../constants/error_msgs\");\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nvar binding_to_syntax_1 = require(\"../syntax/binding_to_syntax\");\nvar metadata_1 = require(\"../planning/metadata\");\nvar target_1 = require(\"../planning/target\");\nvar request_1 = require(\"../planning/request\");\nvar kernel_snapshot_1 = require(\"./kernel_snapshot\");\nvar Kernel = (function () {\n    function Kernel() {\n        this._planner = new planner_1.default();\n        this._resolver = new resolver_1.default();\n        this._bindingDictionary = new lookup_1.default();\n        this._middleware = null;\n        this._snapshots = [];\n    }\n    Kernel.prototype.load = function () {\n        var _this = this;\n        var modules = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            modules[_i - 0] = arguments[_i];\n        }\n        modules.forEach(function (module) { module(_this); });\n    };\n    Kernel.prototype.applyMiddleware = function () {\n        var middlewares = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            middlewares[_i - 0] = arguments[_i];\n        }\n        this._middleware = middlewares.reverse().reduce(function (prev, curr) {\n            return curr(prev);\n        }, this._resolver.resolve.bind(this._resolver));\n    };\n    Kernel.prototype.bind = function (serviceIdentifier) {\n        var binding = new binding_1.default(serviceIdentifier);\n        this._bindingDictionary.add(serviceIdentifier, binding);\n        return new binding_to_syntax_1.default(binding);\n    };\n    Kernel.prototype.unbind = function (serviceIdentifier) {\n        try {\n            this._bindingDictionary.remove(serviceIdentifier);\n        }\n        catch (e) {\n            throw new Error(ERROR_MSGS.CANNOT_UNBIND + \" \" + serviceIdentifier);\n        }\n    };\n    Kernel.prototype.unbindAll = function () {\n        this._bindingDictionary = new lookup_1.default();\n    };\n    Kernel.prototype.get = function (serviceIdentifier) {\n        return this._get(serviceIdentifier, null);\n    };\n    Kernel.prototype.getNamed = function (serviceIdentifier, named) {\n        return this.getTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);\n    };\n    Kernel.prototype.getTagged = function (serviceIdentifier, key, value) {\n        var metadata = new metadata_1.default(key, value);\n        var target = new target_1.default(null, serviceIdentifier, metadata);\n        return this._get(serviceIdentifier, target);\n    };\n    Kernel.prototype.getAll = function (serviceIdentifier) {\n        var _this = this;\n        var bindings = this._planner.getBindings(this, serviceIdentifier);\n        switch (bindings.length) {\n            case binding_count_1.default.NoBindingsAvailable:\n                throw new Error(ERROR_MSGS.NOT_REGISTERED + \" \" + serviceIdentifier);\n            case binding_count_1.default.OnlyOneBindingAvailable:\n            case binding_count_1.default.MultipleBindingsAvailable:\n            default:\n                return bindings.map(function (binding) {\n                    return _this._planAndResolve(binding, null);\n                });\n        }\n    };\n    Kernel.prototype.getServiceIdentifierAsString = function (serviceIdentifier) {\n        var type = typeof serviceIdentifier;\n        if (type === \"function\") {\n            var _serviceIdentifier = serviceIdentifier;\n            return _serviceIdentifier.name;\n        }\n        else if (type === \"symbol\") {\n            return serviceIdentifier.toString();\n        }\n        else {\n            var _serviceIdentifier = serviceIdentifier;\n            return _serviceIdentifier;\n        }\n    };\n    Kernel.prototype.snapshot = function () {\n        this._snapshots.push(kernel_snapshot_1.default.of(this._bindingDictionary.clone(), this._middleware));\n    };\n    Kernel.prototype.restore = function () {\n        if (this._snapshots.length === 0) {\n            throw new Error(ERROR_MSGS.NO_MORE_SNAPSHOTS_AVAILABLE);\n        }\n        var snapshot = this._snapshots.pop();\n        this._bindingDictionary = snapshot.bindings;\n        this._middleware = snapshot.middleware;\n    };\n    Kernel.prototype._get = function (serviceIdentifier, target) {\n        var bindings = this._planner.getBindings(this, serviceIdentifier);\n        if (target !== null) {\n            var request = new request_1.default(serviceIdentifier, this._planner.createContext(this), null, bindings, target);\n            bindings = this._planner.getActiveBindings(request, target);\n        }\n        if (bindings.length === binding_count_1.default.NoBindingsAvailable) {\n            throw new Error(ERROR_MSGS.NOT_REGISTERED + \" \" + serviceIdentifier);\n        }\n        else if (bindings.length === binding_count_1.default.OnlyOneBindingAvailable) {\n            return this._planAndResolve(bindings[0], target);\n        }\n        else {\n            throw new Error(ERROR_MSGS.AMBIGUOUS_MATCH + \" \" + serviceIdentifier);\n        }\n    };\n    Kernel.prototype._planAndResolve = function (binding, target) {\n        var context = this._planner.createContext(this);\n        this._planner.createPlan(context, binding, target);\n        return (this._middleware !== null) ? this._middleware(context) : this._resolver.resolve(context);\n    };\n    return Kernel;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Kernel;\n\n},{\"../bindings/binding\":9,\"../bindings/binding_count\":10,\"../constants/error_msgs\":13,\"../constants/metadata_keys\":14,\"../planning/metadata\":21,\"../planning/planner\":23,\"../planning/request\":25,\"../planning/target\":26,\"../resolution/resolver\":27,\"../syntax/binding_to_syntax\":31,\"./kernel_snapshot\":17,\"./lookup\":19}],17:[function(require,module,exports){\n\"use strict\";\nvar KernelSnapshot = (function () {\n    function KernelSnapshot() {\n    }\n    KernelSnapshot.of = function (bindings, middleware) {\n        var snapshot = new KernelSnapshot();\n        snapshot.bindings = bindings;\n        snapshot.middleware = middleware;\n        return snapshot;\n    };\n    return KernelSnapshot;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = KernelSnapshot;\n\n},{}],18:[function(require,module,exports){\n\"use strict\";\nvar KeyValuePair = (function () {\n    function KeyValuePair(serviceIdentifier, value) {\n        this.serviceIdentifier = serviceIdentifier;\n        this.value = new Array();\n        this.value.push(value);\n    }\n    return KeyValuePair;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = KeyValuePair;\n\n},{}],19:[function(require,module,exports){\n\"use strict\";\nvar key_value_pair_1 = require(\"./key_value_pair\");\nvar ERROR_MSGS = require(\"../constants/error_msgs\");\nvar Lookup = (function () {\n    function Lookup() {\n        this._dictionary = [];\n    }\n    Lookup.prototype.add = function (serviceIdentifier, value) {\n        if (serviceIdentifier === null || serviceIdentifier === undefined) {\n            throw new Error(ERROR_MSGS.NULL_ARGUMENT);\n        }\n        ;\n        if (value === null || value === undefined) {\n            throw new Error(ERROR_MSGS.NULL_ARGUMENT);\n        }\n        ;\n        var index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            this._dictionary[index].value.push(value);\n        }\n        else {\n            this._dictionary.push(new key_value_pair_1.default(serviceIdentifier, value));\n        }\n    };\n    Lookup.prototype.get = function (serviceIdentifier) {\n        if (serviceIdentifier === null || serviceIdentifier === undefined) {\n            throw new Error(ERROR_MSGS.NULL_ARGUMENT);\n        }\n        var index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            return this._dictionary[index].value;\n        }\n        else {\n            throw new Error(ERROR_MSGS.KEY_NOT_FOUND);\n        }\n    };\n    Lookup.prototype.remove = function (serviceIdentifier) {\n        if (serviceIdentifier === null || serviceIdentifier === undefined) {\n            throw new Error(ERROR_MSGS.NULL_ARGUMENT);\n        }\n        var index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            this._dictionary.splice(index, 1);\n        }\n        else {\n            throw new Error(ERROR_MSGS.KEY_NOT_FOUND);\n        }\n    };\n    Lookup.prototype.hasKey = function (serviceIdentifier) {\n        if (serviceIdentifier === null || serviceIdentifier === undefined) {\n            throw new Error(ERROR_MSGS.NULL_ARGUMENT);\n        }\n        var index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    Lookup.prototype.clone = function () {\n        var l = new Lookup();\n        for (var _i = 0, _a = this._dictionary; _i < _a.length; _i++) {\n            var entry = _a[_i];\n            for (var _b = 0, _c = entry.value; _b < _c.length; _b++) {\n                var binding = _c[_b];\n                l.add(entry.serviceIdentifier, binding);\n            }\n        }\n        return l;\n    };\n    Lookup.prototype.getIndexByKey = function (serviceIdentifier) {\n        var index = -1;\n        for (var i = 0; i < this._dictionary.length; i++) {\n            var keyValuePair = this._dictionary[i];\n            if (keyValuePair.serviceIdentifier === serviceIdentifier) {\n                index = i;\n            }\n        }\n        return index;\n    };\n    return Lookup;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Lookup;\n\n},{\"../constants/error_msgs\":13,\"./key_value_pair\":18}],20:[function(require,module,exports){\n\"use strict\";\nvar Context = (function () {\n    function Context(kernel) {\n        this.kernel = kernel;\n    }\n    Context.prototype.addPlan = function (plan) {\n        this.plan = plan;\n    };\n    return Context;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Context;\n\n},{}],21:[function(require,module,exports){\n\"use strict\";\nvar Metadata = (function () {\n    function Metadata(key, value) {\n        this.key = key;\n        this.value = value;\n    }\n    return Metadata;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Metadata;\n\n},{}],22:[function(require,module,exports){\n\"use strict\";\nvar Plan = (function () {\n    function Plan(parentContext, rootRequest) {\n        this.parentContext = parentContext;\n        this.rootRequest = rootRequest;\n    }\n    return Plan;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Plan;\n\n},{}],23:[function(require,module,exports){\n\"use strict\";\nvar plan_1 = require(\"./plan\");\nvar context_1 = require(\"./context\");\nvar request_1 = require(\"./request\");\nvar target_1 = require(\"./target\");\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nvar ERROR_MSGS = require(\"../constants/error_msgs\");\nvar binding_type_1 = require(\"../bindings/binding_type\");\nvar Planner = (function () {\n    function Planner() {\n    }\n    Planner.prototype.createContext = function (kernel) {\n        return new context_1.default(kernel);\n    };\n    Planner.prototype.createPlan = function (context, binding, target) {\n        var _this = this;\n        var rootRequest = new request_1.default(binding.serviceIdentifier, context, null, binding, target);\n        var plan = new plan_1.default(context, rootRequest);\n        context.addPlan(plan);\n        var dependencies = this._getDependencies(binding.implementationType);\n        dependencies.forEach(function (dependency) { _this._createSubRequest(rootRequest, dependency); });\n        return plan;\n    };\n    Planner.prototype.getBindings = function (kernel, serviceIdentifier) {\n        var bindings = [];\n        var _kernel = kernel;\n        var _bindingDictionary = _kernel._bindingDictionary;\n        if (_bindingDictionary.hasKey(serviceIdentifier)) {\n            bindings = _bindingDictionary.get(serviceIdentifier);\n        }\n        return bindings;\n    };\n    Planner.prototype.getActiveBindings = function (parentRequest, target) {\n        var bindings = this.getBindings(parentRequest.parentContext.kernel, target.serviceIdentifier);\n        var activeBindings = [];\n        if (bindings.length > 1 && target.isArray() === false) {\n            activeBindings = bindings.filter(function (binding) {\n                var request = new request_1.default(binding.serviceIdentifier, parentRequest.parentContext, parentRequest, binding, target);\n                return binding.constraint(request);\n            });\n        }\n        else {\n            activeBindings = bindings;\n        }\n        return activeBindings;\n    };\n    Planner.prototype._createSubRequest = function (parentRequest, target) {\n        try {\n            var activeBindings = this.getActiveBindings(parentRequest, target);\n            if (activeBindings.length === 0) {\n                var serviceIdentifier = parentRequest.parentContext.kernel.getServiceIdentifierAsString(target.serviceIdentifier);\n                throw new Error(ERROR_MSGS.NOT_REGISTERED + \" \" + serviceIdentifier);\n            }\n            else if (activeBindings.length > 1 && target.isArray() === false) {\n                var serviceIdentifier = parentRequest.parentContext.kernel.getServiceIdentifierAsString(target.serviceIdentifier);\n                throw new Error(ERROR_MSGS.AMBIGUOUS_MATCH + \" \" + serviceIdentifier);\n            }\n            else {\n                this._createChildRequest(parentRequest, target, activeBindings);\n            }\n        }\n        catch (error) {\n            if (error instanceof RangeError) {\n                this._throwWhenCircularDependenciesFound(parentRequest.parentContext.plan.rootRequest);\n            }\n            else {\n                throw new Error(error.message);\n            }\n        }\n    };\n    Planner.prototype._createChildRequest = function (parentRequest, target, bindings) {\n        var _this = this;\n        var childRequest = parentRequest.addChildRequest(target.serviceIdentifier, bindings, target);\n        var subChildRequest = childRequest;\n        bindings.forEach(function (binding) {\n            if (target.isArray()) {\n                subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);\n            }\n            if (binding.type === binding_type_1.default.Instance) {\n                var subDependencies = _this._getDependencies(binding.implementationType);\n                subDependencies.forEach(function (d, index) {\n                    _this._createSubRequest(subChildRequest, d);\n                });\n            }\n        });\n    };\n    Planner.prototype._throwWhenCircularDependenciesFound = function (request, previousServiceIdentifiers) {\n        var _this = this;\n        if (previousServiceIdentifiers === void 0) { previousServiceIdentifiers = []; }\n        previousServiceIdentifiers.push(request.serviceIdentifier);\n        request.childRequests.forEach(function (childRequest) {\n            var serviceIdentifier = childRequest.serviceIdentifier;\n            if (previousServiceIdentifiers.indexOf(serviceIdentifier) === -1) {\n                if (childRequest.childRequests.length > 0) {\n                    _this._throwWhenCircularDependenciesFound(childRequest, previousServiceIdentifiers);\n                }\n                else {\n                    previousServiceIdentifiers.push(serviceIdentifier);\n                }\n            }\n            else {\n                var tailServiceIdentifier = request.parentContext.kernel.getServiceIdentifierAsString(request.serviceIdentifier);\n                throw new Error(ERROR_MSGS.CIRCULAR_DEPENDENCY + \" \" + serviceIdentifier + \" and \" + tailServiceIdentifier);\n            }\n        });\n    };\n    Planner.prototype._getDependencies = function (func) {\n        if (func === null) {\n            return [];\n        }\n        var constructorName = func.name;\n        var targetsTypes = Reflect.getMetadata(METADATA_KEY.PARAM_TYPES, func);\n        if (targetsTypes === undefined) {\n            var msg = ERROR_MSGS.MISSING_INJECTABLE_ANNOTATION + \" \" + constructorName + \".\";\n            throw new Error(msg);\n        }\n        var targetsMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED, func) || [];\n        var targets = [];\n        var _loop_1 = function(i) {\n            var targetType = targetsTypes[i];\n            var targetMetadata = targetsMetadata[i.toString()] || [];\n            var targetMetadataMap = {};\n            targetMetadata.forEach(function (m) {\n                targetMetadataMap[m.key.toString()] = m.value;\n            });\n            var inject = targetMetadataMap[METADATA_KEY.INJECT_TAG];\n            var multiInject = targetMetadataMap[METADATA_KEY.MULTI_INJECT_TAG];\n            var targetName = targetMetadataMap[METADATA_KEY.NAME_TAG];\n            targetType = (inject || multiInject) ? (inject || multiInject) : targetType;\n            if (targetType === Object || targetType === Function || targetType === undefined) {\n                var msg = ERROR_MSGS.MISSING_INJECT_ANNOTATION + \" argument \" + i + \" in class \" + constructorName + \".\";\n                throw new Error(msg);\n            }\n            var target = new target_1.default(targetName, targetType);\n            target.metadata = targetMetadata;\n            targets.push(target);\n        };\n        for (var i = 0; i < func.length; i++) {\n            _loop_1(i);\n        }\n        if (targets.length === 0 && this._baseClassHasDepencencies(func)) {\n            throw new Error(ERROR_MSGS.MISSING_EXPLICIT_CONSTRUCTOR + \" \" + constructorName + \".\");\n        }\n        return targets;\n    };\n    Planner.prototype._baseClassHasDepencencies = function (func) {\n        var baseConstructor = Object.getPrototypeOf(func.prototype).constructor;\n        if (baseConstructor !== Object) {\n            var targetsTypes = Reflect.getMetadata(METADATA_KEY.PARAM_TYPES, baseConstructor);\n            if (baseConstructor.length > 0 && targetsTypes) {\n                return true;\n            }\n            else {\n                return this._baseClassHasDepencencies(baseConstructor);\n            }\n        }\n        else {\n            return false;\n        }\n    };\n    return Planner;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Planner;\n\n},{\"../bindings/binding_type\":12,\"../constants/error_msgs\":13,\"../constants/metadata_keys\":14,\"./context\":20,\"./plan\":22,\"./request\":25,\"./target\":26}],24:[function(require,module,exports){\n\"use strict\";\nvar QueryableString = (function () {\n    function QueryableString(str) {\n        this.str = str;\n    }\n    QueryableString.prototype.startsWith = function (searchString) {\n        return this.str.indexOf(searchString) === 0;\n    };\n    QueryableString.prototype.endsWith = function (searchString) {\n        var reverseString = \"\";\n        var reverseSearchString = searchString.split(\"\").reverse().join(\"\");\n        reverseString = this.str.split(\"\").reverse().join(\"\");\n        return this.startsWith.call({ str: reverseString }, reverseSearchString);\n    };\n    QueryableString.prototype.contains = function (searchString) {\n        return (this.str.indexOf(searchString) !== -1);\n    };\n    QueryableString.prototype.equals = function (compareString) {\n        return this.str === compareString;\n    };\n    QueryableString.prototype.value = function () {\n        return this.str;\n    };\n    return QueryableString;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = QueryableString;\n\n},{}],25:[function(require,module,exports){\n\"use strict\";\nvar Request = (function () {\n    function Request(serviceIdentifier, parentContext, parentRequest, bindings, target) {\n        if (target === void 0) { target = null; }\n        this.serviceIdentifier = serviceIdentifier;\n        this.parentContext = parentContext;\n        this.parentRequest = parentRequest;\n        this.target = target;\n        this.childRequests = [];\n        this.bindings = (Array.isArray(bindings) ? bindings : ((bindings) ? [bindings] : []));\n    }\n    Request.prototype.addChildRequest = function (serviceIdentifier, bindings, target) {\n        var child = new Request(serviceIdentifier, this.parentContext, this, bindings, target);\n        this.childRequests.push(child);\n        return child;\n    };\n    return Request;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Request;\n\n},{}],26:[function(require,module,exports){\n\"use strict\";\nvar metadata_1 = require(\"../planning/metadata\");\nvar queryable_string_1 = require(\"./queryable_string\");\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nvar Target = (function () {\n    function Target(name, serviceIdentifier, namedOrTagged) {\n        this.serviceIdentifier = serviceIdentifier;\n        this.name = new queryable_string_1.default(name || \"\");\n        this.metadata = new Array();\n        var metadataItem = null;\n        if (typeof namedOrTagged === \"string\") {\n            metadataItem = new metadata_1.default(METADATA_KEY.NAMED_TAG, namedOrTagged);\n        }\n        else if (namedOrTagged instanceof metadata_1.default) {\n            metadataItem = namedOrTagged;\n        }\n        if (metadataItem !== null) {\n            this.metadata.push(metadataItem);\n        }\n    }\n    Target.prototype.hasTag = function (key) {\n        for (var i = 0; i < this.metadata.length; i++) {\n            var m = this.metadata[i];\n            if (m.key === key) {\n                return true;\n            }\n        }\n        return false;\n    };\n    Target.prototype.isArray = function () {\n        return this.hasTag(METADATA_KEY.MULTI_INJECT_TAG);\n    };\n    Target.prototype.matchesArray = function (name) {\n        return this.matchesTag(METADATA_KEY.MULTI_INJECT_TAG)(name);\n    };\n    Target.prototype.isNamed = function () {\n        return this.hasTag(METADATA_KEY.NAMED_TAG);\n    };\n    Target.prototype.isTagged = function () {\n        if (this.metadata.length > 1) {\n            return true;\n        }\n        else if (this.metadata.length === 1) {\n            return !this.hasTag(METADATA_KEY.NAMED_TAG);\n        }\n        else {\n            return false;\n        }\n    };\n    Target.prototype.matchesNamedTag = function (name) {\n        return this.matchesTag(METADATA_KEY.NAMED_TAG)(name);\n    };\n    Target.prototype.matchesTag = function (key) {\n        var _this = this;\n        return function (value) {\n            for (var i = 0; i < _this.metadata.length; i++) {\n                var m = _this.metadata[i];\n                if (m.key === key && m.value === value) {\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    return Target;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Target;\n\n},{\"../constants/metadata_keys\":14,\"../planning/metadata\":21,\"./queryable_string\":24}],27:[function(require,module,exports){\n\"use strict\";\nvar binding_scope_1 = require(\"../bindings/binding_scope\");\nvar binding_type_1 = require(\"../bindings/binding_type\");\nvar ERROR_MSGS = require(\"../constants/error_msgs\");\nvar Resolver = (function () {\n    function Resolver() {\n    }\n    Resolver.prototype.resolve = function (context) {\n        var rootRequest = context.plan.rootRequest;\n        return this._resolve(rootRequest);\n    };\n    Resolver.prototype._resolve = function (request) {\n        var _this = this;\n        var bindings = request.bindings;\n        var childRequests = request.childRequests;\n        if (request.target && request.target.isArray() &&\n            (!request.parentRequest.target || !request.parentRequest.target.matchesArray(request.target.serviceIdentifier))) {\n            return childRequests.map(function (childRequest) { return _this._resolve(childRequest); });\n        }\n        else {\n            var result = null;\n            var binding = bindings[0];\n            var isSingleton = binding.scope === binding_scope_1.default.Singleton;\n            if (isSingleton && binding.activated === true) {\n                return binding.cache;\n            }\n            switch (binding.type) {\n                case binding_type_1.default.ConstantValue:\n                    result = binding.cache;\n                    break;\n                case binding_type_1.default.DynamicValue:\n                    result = binding.dynamicValue();\n                    break;\n                case binding_type_1.default.Constructor:\n                    result = binding.implementationType;\n                    break;\n                case binding_type_1.default.Factory:\n                    result = binding.factory(request.parentContext);\n                    break;\n                case binding_type_1.default.Provider:\n                    result = binding.provider(request.parentContext);\n                    break;\n                case binding_type_1.default.Instance:\n                    var constr = binding.implementationType;\n                    if (childRequests.length > 0) {\n                        var injections = childRequests.map(function (childRequest) {\n                            return _this._resolve(childRequest);\n                        });\n                        result = this._createInstance(constr, injections);\n                    }\n                    else {\n                        result = new constr();\n                    }\n                    break;\n                case binding_type_1.default.Invalid:\n                default:\n                    var serviceIdentifier = request.parentContext.kernel.getServiceIdentifierAsString(request.serviceIdentifier);\n                    throw new Error(ERROR_MSGS.INVALID_BINDING_TYPE + \" \" + serviceIdentifier);\n            }\n            if (typeof binding.onActivation === \"function\") {\n                result = binding.onActivation(request.parentContext, result);\n            }\n            if (isSingleton) {\n                binding.cache = result;\n                binding.activated = true;\n            }\n            return result;\n        }\n    };\n    Resolver.prototype._createInstance = function (Func, injections) {\n        return new (Func.bind.apply(Func, [void 0].concat(injections)))();\n    };\n    return Resolver;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Resolver;\n\n},{\"../bindings/binding_scope\":11,\"../bindings/binding_type\":12,\"../constants/error_msgs\":13}],28:[function(require,module,exports){\n\"use strict\";\nvar binding_scope_1 = require(\"../bindings/binding_scope\");\nvar binding_when_on_syntax_1 = require(\"./binding_when_on_syntax\");\nvar BindingInSyntax = (function () {\n    function BindingInSyntax(binding) {\n        this._binding = binding;\n    }\n    BindingInSyntax.prototype.inSingletonScope = function () {\n        this._binding.scope = binding_scope_1.default.Singleton;\n        return new binding_when_on_syntax_1.default(this._binding);\n    };\n    return BindingInSyntax;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BindingInSyntax;\n\n},{\"../bindings/binding_scope\":11,\"./binding_when_on_syntax\":32}],29:[function(require,module,exports){\n\"use strict\";\nvar binding_in_syntax_1 = require(\"./binding_in_syntax\");\nvar binding_when_syntax_1 = require(\"./binding_when_syntax\");\nvar binding_on_syntax_1 = require(\"./binding_on_syntax\");\nvar BindingInWhenOnSyntax = (function () {\n    function BindingInWhenOnSyntax(binding) {\n        this._binding = binding;\n        this._bindingWhenSyntax = new binding_when_syntax_1.default(this._binding);\n        this._bindingOnSyntax = new binding_on_syntax_1.default(this._binding);\n        this._bindingInSyntax = new binding_in_syntax_1.default(binding);\n    }\n    BindingInWhenOnSyntax.prototype.inSingletonScope = function () {\n        return this._bindingInSyntax.inSingletonScope();\n    };\n    BindingInWhenOnSyntax.prototype.when = function (constraint) {\n        return this._bindingWhenSyntax.when(constraint);\n    };\n    BindingInWhenOnSyntax.prototype.whenTargetNamed = function (name) {\n        return this._bindingWhenSyntax.whenTargetNamed(name);\n    };\n    BindingInWhenOnSyntax.prototype.whenTargetTagged = function (tag, value) {\n        return this._bindingWhenSyntax.whenTargetTagged(tag, value);\n    };\n    BindingInWhenOnSyntax.prototype.whenInjectedInto = function (parent) {\n        return this._bindingWhenSyntax.whenInjectedInto(parent);\n    };\n    BindingInWhenOnSyntax.prototype.whenParentNamed = function (name) {\n        return this._bindingWhenSyntax.whenParentNamed(name);\n    };\n    BindingInWhenOnSyntax.prototype.whenParentTagged = function (tag, value) {\n        return this._bindingWhenSyntax.whenParentTagged(tag, value);\n    };\n    BindingInWhenOnSyntax.prototype.whenAnyAncestorIs = function (ancestor) {\n        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);\n    };\n    BindingInWhenOnSyntax.prototype.whenNoAncestorIs = function (ancestor) {\n        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);\n    };\n    BindingInWhenOnSyntax.prototype.whenAnyAncestorNamed = function (name) {\n        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);\n    };\n    BindingInWhenOnSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {\n        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);\n    };\n    BindingInWhenOnSyntax.prototype.whenNoAncestorNamed = function (name) {\n        return this._bindingWhenSyntax.whenNoAncestorNamed(name);\n    };\n    BindingInWhenOnSyntax.prototype.whenNoAncestorTagged = function (tag, value) {\n        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);\n    };\n    BindingInWhenOnSyntax.prototype.whenAnyAncestorMatches = function (constraint) {\n        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);\n    };\n    BindingInWhenOnSyntax.prototype.whenNoAncestorMatches = function (constraint) {\n        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);\n    };\n    BindingInWhenOnSyntax.prototype.onActivation = function (handler) {\n        return this._bindingOnSyntax.onActivation(handler);\n    };\n    return BindingInWhenOnSyntax;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BindingInWhenOnSyntax;\n\n},{\"./binding_in_syntax\":28,\"./binding_on_syntax\":30,\"./binding_when_syntax\":33}],30:[function(require,module,exports){\n\"use strict\";\nvar binding_when_syntax_1 = require(\"./binding_when_syntax\");\nvar BindingOnSyntax = (function () {\n    function BindingOnSyntax(binding) {\n        this._binding = binding;\n    }\n    BindingOnSyntax.prototype.onActivation = function (handler) {\n        this._binding.onActivation = handler;\n        return new binding_when_syntax_1.default(this._binding);\n    };\n    return BindingOnSyntax;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BindingOnSyntax;\n\n},{\"./binding_when_syntax\":33}],31:[function(require,module,exports){\n\"use strict\";\nvar binding_in_when_on_syntax_1 = require(\"./binding_in_when_on_syntax\");\nvar binding_when_on_syntax_1 = require(\"./binding_when_on_syntax\");\nvar binding_type_1 = require(\"../bindings/binding_type\");\nvar BindingToSyntax = (function () {\n    function BindingToSyntax(binding) {\n        this._binding = binding;\n    }\n    BindingToSyntax.prototype.to = function (constructor) {\n        this._binding.type = binding_type_1.default.Instance;\n        this._binding.implementationType = constructor;\n        return new binding_in_when_on_syntax_1.default(this._binding);\n    };\n    BindingToSyntax.prototype.toConstantValue = function (value) {\n        this._binding.type = binding_type_1.default.ConstantValue;\n        this._binding.cache = value;\n        this._binding.dynamicValue = null;\n        this._binding.implementationType = null;\n        return new binding_when_on_syntax_1.default(this._binding);\n    };\n    BindingToSyntax.prototype.toDynamicValue = function (func) {\n        this._binding.type = binding_type_1.default.DynamicValue;\n        this._binding.cache = null;\n        this._binding.dynamicValue = func;\n        this._binding.implementationType = null;\n        return new binding_when_on_syntax_1.default(this._binding);\n    };\n    BindingToSyntax.prototype.toConstructor = function (constructor) {\n        this._binding.type = binding_type_1.default.Constructor;\n        this._binding.implementationType = constructor;\n        return new binding_when_on_syntax_1.default(this._binding);\n    };\n    BindingToSyntax.prototype.toFactory = function (factory) {\n        this._binding.type = binding_type_1.default.Factory;\n        this._binding.factory = factory;\n        return new binding_when_on_syntax_1.default(this._binding);\n    };\n    BindingToSyntax.prototype.toAutoFactory = function (serviceIdentifier) {\n        this._binding.type = binding_type_1.default.Factory;\n        this._binding.factory = function (context) {\n            return function () {\n                return context.kernel.get(serviceIdentifier);\n            };\n        };\n        return new binding_when_on_syntax_1.default(this._binding);\n    };\n    BindingToSyntax.prototype.toProvider = function (provider) {\n        this._binding.type = binding_type_1.default.Provider;\n        this._binding.provider = provider;\n        return new binding_when_on_syntax_1.default(this._binding);\n    };\n    return BindingToSyntax;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BindingToSyntax;\n\n},{\"../bindings/binding_type\":12,\"./binding_in_when_on_syntax\":29,\"./binding_when_on_syntax\":32}],32:[function(require,module,exports){\n\"use strict\";\nvar binding_when_syntax_1 = require(\"./binding_when_syntax\");\nvar binding_on_syntax_1 = require(\"./binding_on_syntax\");\nvar BindingWhenOnSyntax = (function () {\n    function BindingWhenOnSyntax(binding) {\n        this._binding = binding;\n        this._bindingWhenSyntax = new binding_when_syntax_1.default(this._binding);\n        this._bindingOnSyntax = new binding_on_syntax_1.default(this._binding);\n    }\n    BindingWhenOnSyntax.prototype.when = function (constraint) {\n        return this._bindingWhenSyntax.when(constraint);\n    };\n    BindingWhenOnSyntax.prototype.whenTargetNamed = function (name) {\n        return this._bindingWhenSyntax.whenTargetNamed(name);\n    };\n    BindingWhenOnSyntax.prototype.whenTargetTagged = function (tag, value) {\n        return this._bindingWhenSyntax.whenTargetTagged(tag, value);\n    };\n    BindingWhenOnSyntax.prototype.whenInjectedInto = function (parent) {\n        return this._bindingWhenSyntax.whenInjectedInto(parent);\n    };\n    BindingWhenOnSyntax.prototype.whenParentNamed = function (name) {\n        return this._bindingWhenSyntax.whenParentNamed(name);\n    };\n    BindingWhenOnSyntax.prototype.whenParentTagged = function (tag, value) {\n        return this._bindingWhenSyntax.whenParentTagged(tag, value);\n    };\n    BindingWhenOnSyntax.prototype.whenAnyAncestorIs = function (ancestor) {\n        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);\n    };\n    BindingWhenOnSyntax.prototype.whenNoAncestorIs = function (ancestor) {\n        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);\n    };\n    BindingWhenOnSyntax.prototype.whenAnyAncestorNamed = function (name) {\n        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);\n    };\n    BindingWhenOnSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {\n        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);\n    };\n    BindingWhenOnSyntax.prototype.whenNoAncestorNamed = function (name) {\n        return this._bindingWhenSyntax.whenNoAncestorNamed(name);\n    };\n    BindingWhenOnSyntax.prototype.whenNoAncestorTagged = function (tag, value) {\n        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);\n    };\n    BindingWhenOnSyntax.prototype.whenAnyAncestorMatches = function (constraint) {\n        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);\n    };\n    BindingWhenOnSyntax.prototype.whenNoAncestorMatches = function (constraint) {\n        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);\n    };\n    BindingWhenOnSyntax.prototype.onActivation = function (handler) {\n        return this._bindingOnSyntax.onActivation(handler);\n    };\n    return BindingWhenOnSyntax;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BindingWhenOnSyntax;\n\n},{\"./binding_on_syntax\":30,\"./binding_when_syntax\":33}],33:[function(require,module,exports){\n\"use strict\";\nvar binding_on_syntax_1 = require(\"./binding_on_syntax\");\nvar constraint_helpers_1 = require(\"./constraint_helpers\");\nvar BindingWhenSyntax = (function () {\n    function BindingWhenSyntax(binding) {\n        this._binding = binding;\n    }\n    BindingWhenSyntax.prototype.when = function (constraint) {\n        this._binding.constraint = constraint;\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenTargetNamed = function (name) {\n        this._binding.constraint = constraint_helpers_1.namedConstraint(name);\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenTargetTagged = function (tag, value) {\n        this._binding.constraint = constraint_helpers_1.taggedConstraint(tag)(value);\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenInjectedInto = function (parent) {\n        this._binding.constraint = function (request) {\n            return constraint_helpers_1.typeConstraint(parent)(request.parentRequest);\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenParentNamed = function (name) {\n        this._binding.constraint = function (request) {\n            return constraint_helpers_1.namedConstraint(name)(request.parentRequest);\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenParentTagged = function (tag, value) {\n        this._binding.constraint = function (request) {\n            return constraint_helpers_1.taggedConstraint(tag)(value)(request.parentRequest);\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenAnyAncestorIs = function (ancestor) {\n        this._binding.constraint = function (request) {\n            return constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.typeConstraint(ancestor));\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenNoAncestorIs = function (ancestor) {\n        this._binding.constraint = function (request) {\n            return !constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.typeConstraint(ancestor));\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenAnyAncestorNamed = function (name) {\n        this._binding.constraint = function (request) {\n            return constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.namedConstraint(name));\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenNoAncestorNamed = function (name) {\n        this._binding.constraint = function (request) {\n            return !constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.namedConstraint(name));\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {\n        this._binding.constraint = function (request) {\n            return constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.taggedConstraint(tag)(value));\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenNoAncestorTagged = function (tag, value) {\n        this._binding.constraint = function (request) {\n            return !constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.taggedConstraint(tag)(value));\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenAnyAncestorMatches = function (constraint) {\n        this._binding.constraint = function (request) {\n            return constraint_helpers_1.traverseAncerstors(request, constraint);\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenNoAncestorMatches = function (constraint) {\n        this._binding.constraint = function (request) {\n            return !constraint_helpers_1.traverseAncerstors(request, constraint);\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    return BindingWhenSyntax;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BindingWhenSyntax;\n\n},{\"./binding_on_syntax\":30,\"./constraint_helpers\":34}],34:[function(require,module,exports){\n\"use strict\";\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nvar traverseAncerstors = function (request, constraint) {\n    var parent = request.parentRequest;\n    if (parent !== null) {\n        return constraint(parent) ? true : traverseAncerstors(parent, constraint);\n    }\n    else {\n        return false;\n    }\n};\nexports.traverseAncerstors = traverseAncerstors;\nvar taggedConstraint = function (key) { return function (value) { return function (request) {\n    return request.target.matchesTag(key)(value);\n}; }; };\nexports.taggedConstraint = taggedConstraint;\nvar namedConstraint = taggedConstraint(METADATA_KEY.NAMED_TAG);\nexports.namedConstraint = namedConstraint;\nvar typeConstraint = function (type) { return function (request) {\n    var binding = request.bindings[0];\n    if (typeof type === \"string\") {\n        var serviceIdentifier = binding.serviceIdentifier;\n        return serviceIdentifier === type;\n    }\n    else {\n        var constructor = request.bindings[0].implementationType;\n        return type === constructor;\n    }\n}; };\nexports.typeConstraint = typeConstraint;\n\n},{\"../constants/metadata_keys\":14}]},{},[15])(15)\n});\n\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\nimport * as ERROR_MSGS from \"../constants/error_msgs\";\n\ninterface IReflectResult {\n    [key: string]: IMetadata[];\n}\n\nfunction tagParameter(annotationTarget: any, propertyName: string, parameterIndex: number, metadata: IMetadata) {\n    let metadataKey = METADATA_KEY.TAGGED;\n    return _tagParameterOrProperty(metadataKey, annotationTarget, propertyName, metadata, parameterIndex);\n}\n\nfunction tagProperty(annotationTarget: any, propertyName: string, metadata: IMetadata) {\n    let metadataKey = METADATA_KEY.TAGGED_PROP;\n    return _tagParameterOrProperty(metadataKey, annotationTarget.constructor, propertyName, metadata);\n}\n\nfunction _tagParameterOrProperty(\n    metadataKey: string, annotationTarget: any, propertyName: string, metadata: IMetadata, parameterIndex?: number\n) {\n\n    let paramsOrPropertiesMetadata: IReflectResult = null;\n    let isParameterDecorator = (typeof parameterIndex === \"number\");\n    let key: string = (isParameterDecorator) ? parameterIndex.toString() : propertyName;\n\n    // If the decorator is used as a parameter decorator property name must be provided\n    if (isParameterDecorator === true && propertyName !== undefined) {\n        throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);\n    }\n\n    // read metadata if avalible\n    if (Reflect.hasOwnMetadata(metadataKey, annotationTarget) !== true) {\n        paramsOrPropertiesMetadata = {};\n    } else {\n        paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);\n    }\n\n    // get metadata for the decorated parameter by its index\n    let paramOrPropertyMetadata: IMetadata[] = paramsOrPropertiesMetadata[key];\n    if (Array.isArray(paramOrPropertyMetadata) !== true) {\n        paramOrPropertyMetadata = [];\n    } else {\n        for (let i = 0; i < paramOrPropertyMetadata.length; i++) {\n            let m: IMetadata = paramOrPropertyMetadata[i];\n            if (m.key === metadata.key) {\n                throw new Error(`${ERROR_MSGS.DUPLICATED_METADATA} ${m.key}`);\n            }\n        }\n    }\n\n    // set metadata\n    paramOrPropertyMetadata.push(metadata);\n    paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;\n    Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);\n    return annotationTarget;\n\n}\n\nfunction _decorate(decorators: ClassDecorator[], target: any): void {\n    Reflect.decorate(decorators, target);\n}\n\nfunction _param(paramIndex: number, decorator: ParameterDecorator): ClassDecorator {\n    return function (target: any, key?: string) { decorator(target, key, paramIndex); };\n}\n\n// Allows VanillaJS developers to use decorators:\n// decorate(injectable(\"IFoo\", \"IBar\"), FooBar);\n// decorate(targetName(\"foo\", \"bar\"), FooBar);\n// decorate(named(\"foo\"), FooBar, 0);\n// decorate(tagged(\"bar\"), FooBar, 1);\nfunction decorate(\n    decorator: (ClassDecorator|ParameterDecorator),\n    target: any,\n    parameterIndex?: number): void {\n\n    if (typeof parameterIndex === \"number\") {\n        _decorate([_param(parameterIndex, <ParameterDecorator>decorator)], target);\n    } else {\n        _decorate([<ClassDecorator>decorator], target);\n    }\n}\n\nexport { decorate, tagParameter, tagProperty };\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\r\n\r\nimport Metadata from \"../planning/metadata\";\r\nimport { tagParameter } from \"./decorator_utils\";\r\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\r\n\r\n// Used to declare types to be injected not available at runtime\r\nfunction inject(serviceIdentifier: (string|Symbol)) {\r\n  return function(target: any, targetKey: string, index: number) {\r\n    let metadata = new Metadata(METADATA_KEY.INJECT_TAG, serviceIdentifier);\r\n    return tagParameter(target, targetKey, index, metadata);\r\n  };\r\n}\r\n\r\nexport default inject;\r\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\nimport * as ERRORS_MSGS from \"../constants/error_msgs\";\n\nfunction injectable() {\n  return function(target: any) {\n\n    if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target) === true) {\n      throw new Error(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);\n    }\n\n    let types = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, target) || [];\n    Reflect.defineMetadata(METADATA_KEY.PARAM_TYPES, types, target);\n\n    return target;\n  };\n}\n\nexport default injectable;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport Metadata from \"../planning/metadata\";\nimport { tagParameter } from \"./decorator_utils\";\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\n\nfunction multiInject(serviceIdentifier: (string|Symbol)) {\n  return function(target: any, targetKey: string, index: number) {\n    let metadata = new Metadata(METADATA_KEY.MULTI_INJECT_TAG, serviceIdentifier);\n    return tagParameter(target, targetKey, index, metadata);\n  };\n}\n\nexport default multiInject;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\r\n\r\nimport Metadata from \"../planning/metadata\";\r\nimport { tagParameter, tagProperty } from \"./decorator_utils\";\r\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\r\n\r\n// Used to add named metadata which is used to resolve name-based contextual bindings.\r\nfunction named(name: string) {\r\n    return function(target: any, targetKey: string, index?: number) {\r\n        let metadata = new Metadata(METADATA_KEY.NAMED_TAG, name);\r\n        if (typeof index === \"number\") {\r\n            return tagParameter(target, targetKey, index, metadata);\r\n        } else {\r\n            return tagProperty(target, targetKey, metadata);\r\n        }\r\n    };\r\n}\r\n\r\nexport default named;\r\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nconst INJECTION = Symbol();\n\nfunction _proxyGetter(\n    proto: any,\n    key: string,\n    resolve: () => any\n) {\n    function getter() {\n        if (!Reflect.hasMetadata(INJECTION, this, key)) {\n            Reflect.defineMetadata(INJECTION, resolve(), this, key);\n        }\n        return Reflect.getMetadata(INJECTION, this, key);\n    }\n\n    function setter(newVal: any) {\n        Reflect.defineMetadata(INJECTION, newVal, this, key);\n    }\n\n    Object.defineProperty(proto, key, {\n        configurable: true,\n        enumerable: true,\n        get: getter,\n        set: setter\n    });\n}\n\nfunction makePropertyInjectDecorator(kernel: IKernel) {\n    return function(serviceIdentifier: (string|Symbol|INewable<any>)) {\n        return function(proto: any, key: string): void {\n\n            let resolve = () => {\n                return kernel.get(serviceIdentifier);\n            };\n\n            _proxyGetter(proto, key, resolve);\n\n        };\n    };\n}\n\nfunction makePropertyInjectNamedDecorator(kernel: IKernel) {\n    return function(serviceIdentifier: (string|Symbol|INewable<any>), named: string) {\n        return function(proto: any, key: string): void {\n\n            let resolve = () => {\n                return kernel.getNamed(serviceIdentifier, named);\n            };\n\n            _proxyGetter(proto, key, resolve);\n\n        };\n    };\n}\n\nfunction makePropertyInjectTaggedDecorator(kernel: IKernel) {\n    return function(serviceIdentifier: (string|Symbol|INewable<any>), key: string, value: any) {\n        return function(proto: any, propertyName: string): void {\n\n            let resolve = () => {\n                return kernel.getTagged(serviceIdentifier, key, value);\n            };\n\n            _proxyGetter(proto, propertyName , resolve);\n\n        };\n    };\n}\n\nfunction makePropertyMultiInjectDecorator(kernel: IKernel) {\n    return function(serviceIdentifier: (string|Symbol|INewable<any>)) {\n        return function(proto: any, key: string): void {\n\n            let resolve = () => {\n                return kernel.getAll(serviceIdentifier);\n            };\n\n            _proxyGetter(proto, key, resolve);\n\n        };\n    };\n}\n\nexport {\n    makePropertyInjectDecorator,\n    makePropertyMultiInjectDecorator,\n    makePropertyInjectTaggedDecorator,\n    makePropertyInjectNamedDecorator\n};\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport Metadata from \"../planning/metadata\";\nimport { tagParameter, tagProperty } from \"./decorator_utils\";\n\n// Used to add custom metadata which is used to resolve metadata-based contextual bindings.\nfunction tagged(metadataKey: string, metadataValue: any) {\n    return function(target: any, targetKey: string, index?: number) {\n        let metadata = new Metadata(metadataKey, metadataValue);\n            if (typeof index === \"number\") {\n        return tagParameter(target, targetKey, index, metadata);\n        } else {\n            return tagProperty(target, targetKey, metadata);\n        }\n    };\n}\n\nexport default tagged;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport Metadata from \"../planning/metadata\";\nimport { tagParameter } from \"./decorator_utils\";\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\n\nfunction targetName(name: string) {\n  return function(target: any, targetKey: string, index: number) {\n    let metadata = new Metadata(METADATA_KEY.NAME_TAG, name);\n    return tagParameter(target, targetKey, index, metadata);\n  };\n}\n\nexport default targetName;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\n// Binding\n// -----------\n\n// A type binding (or just a binding) is a mapping between a service type\n// (an interface), and an implementation type to be used to satisfy such\n// a service requirement.\n\nimport BindingScope from \"./binding_scope\";\nimport BindingType from \"./binding_type\";\n\nclass Binding<T> implements IBinding<T> {\n\n    // Determines wether the bindings has been already activated\n    // The activation action takes place when an instance is resolved\n    // If the scope is singleton it only happens once\n    public activated: boolean;\n\n    // A runtime identifier because at runtime we don't have interfaces\n    public serviceIdentifier: (string|Symbol|INewable<T>);\n\n    // The constructor of a class which must implement T\n    public implementationType: INewable<T>;\n\n    // Cache used to allow singleton scope and BindingType.ConstantValue bindings\n    public cache: T;\n\n    // Cache used to allow BindingType.DynamicValue bindings\n    public dynamicValue: () => T;\n\n    // The scope mode to be used\n    public scope: BindingScope;\n\n    // The kind of binding\n    public type: BindingType;\n\n    // A factory method used in BindingType.Factory bindings\n    public factory: IFactoryCreator<T>;\n\n    // An async factory method used in BindingType.Provider bindings\n    public provider: IProviderCreator<T>;\n\n    // A constraint used to limit the contexts in which this binding is applicable\n    public constraint: (request: IRequest) => boolean;\n\n    // On activation handler (invoked just before an instance is added to cache and injected)\n    public onActivation: (context: IContext, injectable: T) => T;\n\n    constructor(serviceIdentifier: (string|Symbol|INewable<T>)) {\n        this.activated = false;\n        this.serviceIdentifier = serviceIdentifier;\n        this.scope = BindingScope.Transient;\n        this.type = BindingType.Invalid;\n        this.constraint = (request: IRequest) => { return true; };\n        this.implementationType = null;\n        this.cache = null;\n        this.factory = null;\n        this.provider = null;\n        this.onActivation = null;\n    }\n}\n\nexport default Binding;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nenum BindingCount {\n    NoBindingsAvailable = 0,\n    OnlyOneBindingAvailable = 1,\n    MultipleBindingsAvailable = 2\n}\n\nexport default BindingCount;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nenum BindingScope {\n  Transient = 0,\n  Singleton = 1\n}\n\nexport default BindingScope;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nenum BindingType {\n  Invalid = 0,\n  Instance = 1,\n  ConstantValue = 2,\n  DynamicValue = 3,\n  Constructor = 4,\n  Factory = 5,\n  Provider = 6\n}\n\nexport default BindingType;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nexport const DUPLICATED_INJECTABLE_DECORATOR = \"Cannot apply @injectable decorator multiple times.\";\nexport const DUPLICATED_METADATA = \"Metadadata key was used more than once in a parameter:\";\nexport const NULL_ARGUMENT = \"NULL argument\";\nexport const KEY_NOT_FOUND = \"Key Not Found\";\nexport const AMBIGUOUS_MATCH = \"Ambiguous match found for serviceIdentifier:\";\nexport const CANNOT_UNBIND = \"Could not unbind serviceIdentifier:\";\nexport const NOT_REGISTERED = \"No bindings found for serviceIdentifier:\";\nexport const MISSING_INJECTABLE_ANNOTATION = \"Missing required @injectable annotation in:\";\nexport const MISSING_INJECT_ANNOTATION = \"Missing required @inject or @multiInject annotation in:\";\nexport const CIRCULAR_DEPENDENCY = \"Circular dependency found between services:\";\nexport const NOT_IMPLEMENTED = \"Sorry, this feature is not fully implemented yet.\";\nexport const INVALID_BINDING_TYPE = \"Invalid binding type:\";\nexport const MISSING_EXPLICIT_CONSTRUCTOR = \"Derived class must explicitly declare its constructor:\";\nexport const INVALID_DECORATOR_OPERATION = \"The @inject @multiInject @tagged and @named decorators \" +\n    \"must be applied to the parameters of a class constructor or a class property.\";\nexport const NO_MORE_SNAPSHOTS_AVAILABLE = \"No snapshot available to restore.\";\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\n// Used for named bindings\nexport const NAMED_TAG = \"named\";\n\n// The name of the target at design time\nexport const NAME_TAG = \"name\";\n\n// The type of the binding at design time\nexport const INJECT_TAG = \"inject\";\n\n// The type of the binding at design type for multi-injections\nexport const MULTI_INJECT_TAG = \"multi_inject\";\n\n// used to store constructor arguments tags \nexport const TAGGED = \"inversify:tagged\";\n\n// used to store class properties tags\nexport const TAGGED_PROP = \"inversify:tagged_props\";\n\n// used to store types to be injected\nexport const PARAM_TYPES = \"inversify:paramtypes\";\n\n// used to access design time types\nexport const DESIGN_PARAM_TYPES = \"design:paramtypes\";\n","///<reference path=\"./interfaces/interfaces.d.ts\" />\n\n// Inversify\n// ---------\n\n// The Inversify main file, the library entry point.\n\nimport Kernel from \"./kernel/kernel\";\nimport injectable from \"./annotation/injectable\";\nimport tagged from \"./annotation/tagged\";\nimport named from \"./annotation/named\";\nimport inject from \"./annotation/inject\";\nimport { makePropertyInjectDecorator, makePropertyMultiInjectDecorator } from \"./annotation/property_injectors\";\nimport multiInject from \"./annotation/multi_inject\";\nimport targetName from \"./annotation/target_name\";\nimport { decorate } from \"./annotation/decorator_utils\";\nimport { traverseAncerstors, taggedConstraint, namedConstraint, typeConstraint } from \"./syntax/constraint_helpers\";\n\nexport { Kernel };\nexport { decorate };\nexport { injectable };\nexport { tagged };\nexport { named };\nexport { inject };\nexport { makePropertyInjectDecorator, makePropertyMultiInjectDecorator };\nexport { multiInject };\nexport { targetName };\nexport { traverseAncerstors };\nexport { taggedConstraint };\nexport { namedConstraint };\nexport { typeConstraint };\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\n// Kernel\n// ------\n\n// Inversify is a lightweight pico container for TypeScript\n// and JavaScript apps.\n\n// A pico container uses a class constructor to identify and\n// inject its dependencies. For this to work, the class needs\n// to declare a constructor that includes everything it\n// needs injected.\n\n// In order to resolve a dependency, the pico container needs\n// to be told which implementation type (classes) to associate\n// with each service type (interfaces).\n\nimport BindingCount from \"../bindings/binding_count\";\nimport Binding from \"../bindings/binding\";\nimport Lookup from \"./lookup\";\nimport Planner from \"../planning/planner\";\nimport Resolver from \"../resolution/resolver\";\nimport * as ERROR_MSGS from \"../constants/error_msgs\";\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\nimport BindingToSyntax from \"../syntax/binding_to_syntax\";\nimport Metadata from \"../planning/metadata\";\nimport Target from \"../planning/target\";\nimport Request from \"../planning/request\";\nimport KernelSnapshot from \"./kernel_snapshot\";\n\nclass Kernel implements IKernel {\n    private _planner: IPlanner;\n    private _resolver: IResolver;\n    private _middleware: (context: IContext) => any;\n    private _bindingDictionary: ILookup<IBinding<any>>;\n    private _snapshots: Array<KernelSnapshot>;\n\n    // Initialize private properties\n    public constructor() {\n        this._planner = new Planner();\n        this._resolver = new Resolver();\n        this._bindingDictionary = new Lookup<IBinding<any>>();\n        this._middleware = null;\n        this._snapshots = [];\n    }\n\n    public load(...modules: IKernelModule[]): void {\n        modules.forEach((module) => { module(this); });\n    }\n\n    public applyMiddleware(...middlewares: IMiddleware[]): void {\n        this._middleware = middlewares.reverse().reduce((prev, curr) => {\n            return curr(prev);\n        }, this._resolver.resolve.bind(this._resolver));\n    }\n\n    // Regiters a type binding\n    public bind<T>(serviceIdentifier: (string|Symbol|INewable<T>)): IBindingToSyntax<T> {\n        let binding = new Binding<T>(serviceIdentifier);\n        this._bindingDictionary.add(serviceIdentifier, binding);\n        return new BindingToSyntax<T>(binding);\n    }\n\n    // Removes a type binding from the registry by its key\n    public unbind(serviceIdentifier: (string|Symbol|any)): void {\n        try {\n            this._bindingDictionary.remove(serviceIdentifier);\n        } catch (e) {\n            throw new Error(`${ERROR_MSGS.CANNOT_UNBIND} ${serviceIdentifier}`);\n        }\n    }\n\n    // Removes all the type bindings from the registry\n    public unbindAll(): void {\n        this._bindingDictionary = new Lookup<IBinding<any>>();\n    }\n\n    // Resolves a dependency by its runtime identifier\n    // The runtime identifier must be associated with only one binding\n    // use getAll when the runtime identifier is associated with multiple bindings\n    public get<T>(serviceIdentifier: (string|Symbol|INewable<T>)): T {\n        return this._get<T>(serviceIdentifier, null);\n    }\n\n    public getNamed<T>(serviceIdentifier: (string|Symbol|INewable<T>), named: string): T {\n        return this.getTagged<T>(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);\n    }\n\n    public getTagged<T>(serviceIdentifier: (string|Symbol|INewable<T>), key: string, value: any): T {\n        let metadata = new Metadata(key, value);\n        let target = new Target(null, serviceIdentifier, metadata);\n        return this._get<T>(serviceIdentifier, target);\n    }\n\n    // Resolves a dependency by its runtime identifier\n    // The runtime identifier can be associated with one or multiple bindings\n    public getAll<T>(serviceIdentifier: (string|Symbol|INewable<T>)): T[] {\n\n        let bindings = this._planner.getBindings<T>(this, serviceIdentifier);\n\n        switch (bindings.length) {\n\n            // CASE 1: There are no bindings\n            case BindingCount.NoBindingsAvailable:\n                throw new Error(`${ERROR_MSGS.NOT_REGISTERED} ${serviceIdentifier}`);\n\n            // CASE 2: There is AT LEAST 1 binding    \n            case BindingCount.OnlyOneBindingAvailable:\n            case BindingCount.MultipleBindingsAvailable:\n            default:\n                return bindings.map((binding) => {\n                    return this._planAndResolve<T>(binding, null);\n                });\n        }\n    }\n\n    public getServiceIdentifierAsString(serviceIdentifier: (string|Symbol|INewable<any>)): string {\n        let type = typeof serviceIdentifier;\n        if (type === \"function\") {\n            let _serviceIdentifier: any = serviceIdentifier;\n            return _serviceIdentifier.name;\n        } else if (type === \"symbol\") {\n            return serviceIdentifier.toString();\n        } else { // string\n            let _serviceIdentifier: any = serviceIdentifier;\n            return _serviceIdentifier;\n        }\n    }\n\n    public snapshot (): void {\n        this._snapshots.push(KernelSnapshot.of(this._bindingDictionary.clone(), this._middleware));\n    }\n\n    public restore (): void {\n        if (this._snapshots.length === 0) {\n            throw new Error(ERROR_MSGS.NO_MORE_SNAPSHOTS_AVAILABLE);\n        }\n        let snapshot = this._snapshots.pop();\n        this._bindingDictionary = snapshot.bindings;\n        this._middleware = snapshot.middleware;\n    }\n\n    private _get<T>(serviceIdentifier: (string|Symbol|INewable<T>), target: ITarget): T {\n\n        let bindings = this._planner.getBindings<T>(this, serviceIdentifier);\n\n        // Filter bindings using the target and the binding constraints\n        if (target !== null) {\n\n            let request = new Request(\n                serviceIdentifier,\n                this._planner.createContext(this),\n                null,\n                bindings,\n                target\n            );\n\n            bindings = this._planner.getActiveBindings(request, target);\n        }\n\n        if (bindings.length === BindingCount.NoBindingsAvailable) {\n\n            // CASE 1: There are no bindings\n            throw new Error(`${ERROR_MSGS.NOT_REGISTERED} ${serviceIdentifier}`);\n\n        } else if (bindings.length === BindingCount.OnlyOneBindingAvailable) {\n\n            // CASE 2: There is 1 binding\n            return this._planAndResolve<T>(bindings[0], target);\n\n        } else {\n\n            // CASE 3: There are multiple bindings\n            throw new Error(`${ERROR_MSGS.AMBIGUOUS_MATCH} ${serviceIdentifier}`);\n\n        }\n\n    }\n\n    // Generates an executes a resolution plan\n    private _planAndResolve<T>(binding: IBinding<T>, target: ITarget): T {\n\n        // STEP 1: generate resolution context\n        let context = this._planner.createContext(this);\n\n        // STEP 2: generate a resolutioin plan & link it to the context\n        this._planner.createPlan(context, binding, target);\n\n        // STEP 3, 4 & 5: use middleware (optional), execute resolution plan & activation\n        return (this._middleware !== null) ? this._middleware(context) : this._resolver.resolve<T>(context);\n    }\n\n}\n\nexport default Kernel;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nexport default class KernelSnapshot implements IKernelSnapshot {\n    public bindings: ILookup<IBinding<any>>;\n    public middleware: (context: IContext) => void;\n\n    public static of(bindings: ILookup<IBinding<any>>, middleware: (context: IContext) => void) {\n        let snapshot = new KernelSnapshot();\n        snapshot.bindings = bindings;\n        snapshot.middleware = middleware;\n        return snapshot;\n    }\n}\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nclass KeyValuePair<T> implements IKeyValuePair<T> {\n\n    public serviceIdentifier: (string|Symbol|any);\n    public value: Array<T>;\n\n    public constructor(serviceIdentifier: (string|Symbol|any), value: T) {\n        this.serviceIdentifier = serviceIdentifier;\n        this.value = new Array<T>();\n        this.value.push(value);\n    }\n}\n\nexport default KeyValuePair;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\n// TypeBinding\n// -----------\n\n// A dictionary with support for duplicate keys\n\nimport KeyValuePair from \"./key_value_pair\";\nimport * as ERROR_MSGS from \"../constants/error_msgs\";\n\nclass Lookup<T> implements ILookup<T> {\n\t// dictionary used store multiple values for each key <key>\n    private _dictionary: Array<IKeyValuePair<T>>;\n\n    public constructor() {\n        this._dictionary = [];\n    }\n\n\t// adds a new KeyValuePair to _dictionary\n    public add(serviceIdentifier: (string|Symbol|any), value: T): void {\n\n        if (serviceIdentifier === null || serviceIdentifier === undefined) { throw new Error(ERROR_MSGS.NULL_ARGUMENT); };\n        if (value === null || value === undefined) { throw new Error(ERROR_MSGS.NULL_ARGUMENT); };\n\n        let index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            this._dictionary[index].value.push(value);\n        } else {\n            this._dictionary.push(new KeyValuePair(serviceIdentifier, value));\n        }\n    }\n\n    // gets the value of a KeyValuePair by its serviceIdentifier\n    public get(serviceIdentifier: (string|Symbol|any)): Array<T> {\n\n        if (serviceIdentifier === null || serviceIdentifier === undefined) { throw new Error(ERROR_MSGS.NULL_ARGUMENT); }\n\n        let index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            return this._dictionary[index].value;\n        } else {\n            throw new Error(ERROR_MSGS.KEY_NOT_FOUND);\n        }\n    }\n\n\t// removes a KeyValuePair from _dictionary by its serviceIdentifier\n    public remove(serviceIdentifier: (string|Symbol|any)): void {\n\n        if (serviceIdentifier === null || serviceIdentifier === undefined) { throw new Error(ERROR_MSGS.NULL_ARGUMENT); }\n\n        let index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            this._dictionary.splice(index, 1);\n        } else {\n            throw new Error(ERROR_MSGS.KEY_NOT_FOUND);\n        }\n    }\n\n    // returns true if _dictionary contains serviceIdentifier\n    public hasKey(serviceIdentifier: (string|Symbol|any)): boolean {\n\n        if (serviceIdentifier === null || serviceIdentifier === undefined) { throw new Error(ERROR_MSGS.NULL_ARGUMENT); }\n\n        let index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // returns a new Lookup instance; note: this is not a deep clone, only Lookup related data structure (dictionary) is\n    // cloned, content remains the same\n    public clone(): ILookup<T> {\n        let l = new Lookup<T>();\n\n        for (let entry of this._dictionary) {\n            for (let binding of entry.value) {\n                l.add(entry.serviceIdentifier, binding);\n            }\n        }\n\n        return l;\n    }\n\n\t// finds the location of a KeyValuePair pair in _dictionary by its serviceIdentifier\n    private getIndexByKey(serviceIdentifier: (string|Symbol|any)): number {\n        let index = -1;\n        for (let i = 0; i < this._dictionary.length; i++) {\n            let keyValuePair = this._dictionary[i];\n            if (keyValuePair.serviceIdentifier === serviceIdentifier) {\n                index = i;\n            }\n        }\n        return index;\n    }\n}\n\nexport default Lookup;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nclass Context<TService> implements IContext {\n\n    public kernel: IKernel;\n    public plan: IPlan;\n\n    public constructor(kernel: IKernel) {\n        this.kernel = kernel;\n    }\n\n    public addPlan(plan: IPlan) {\n        this.plan = plan;\n    }\n}\n\nexport default Context;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nclass Metadata implements IMetadata {\n\n  public key: string;\n  public value: any;\n\n  constructor(key: string, value: any) {\n      this.key = key;\n      this.value = value;\n  }\n}\n\nexport default Metadata;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nclass Plan implements IPlan {\n\n    public parentContext: IContext;\n    public rootRequest: IRequest;\n\n    public constructor(parentContext: IContext, rootRequest: IRequest) {\n        this.parentContext = parentContext;\n        this.rootRequest = rootRequest;\n    }\n}\n\nexport default Plan;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport Plan from \"./plan\";\nimport Context from \"./context\";\nimport Request from \"./request\";\nimport Target from \"./target\";\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\nimport * as ERROR_MSGS from \"../constants/error_msgs\";\nimport BindingType from \"../bindings/binding_type\";\n\nclass Planner implements IPlanner {\n\n    public createContext(kernel: IKernel): IContext {\n        return new Context(kernel);\n    }\n\n    public createPlan(context: IContext, binding: IBinding<any>, target: ITarget): IPlan {\n\n        let rootRequest = new Request(\n            binding.serviceIdentifier,\n            context,\n            null,\n            binding,\n            target);\n\n        let plan = new Plan(context, rootRequest);\n\n        // Plan and Context are duable linked\n        context.addPlan(plan);\n\n        let dependencies = this._getDependencies(binding.implementationType);\n        dependencies.forEach((dependency) => { this._createSubRequest(rootRequest, dependency); });\n        return plan;\n    }\n\n    public getBindings<T>(kernel: IKernel, serviceIdentifier: (string|Symbol|INewable<T>)): IBinding<T>[] {\n        let bindings: IBinding<T>[] = [];\n        let _kernel: any = kernel;\n        let _bindingDictionary = _kernel._bindingDictionary;\n        if (_bindingDictionary.hasKey(serviceIdentifier)) {\n            bindings = _bindingDictionary.get(serviceIdentifier);\n        }\n        return bindings;\n    }\n\n    public getActiveBindings(parentRequest: IRequest, target: ITarget): IBinding<any>[] {\n\n        let bindings = this.getBindings<any>(parentRequest.parentContext.kernel, target.serviceIdentifier);\n        let activeBindings: IBinding<any>[] = [];\n\n        if (bindings.length > 1 && target.isArray() === false) {\n\n            // apply constraints if available to reduce the number of active bindings\n            activeBindings = bindings.filter((binding) => {\n\n                let request =  new Request(\n                    binding.serviceIdentifier,\n                    parentRequest.parentContext,\n                    parentRequest,\n                    binding,\n                    target\n                );\n\n                return binding.constraint(request);\n\n            });\n\n        } else {\n            activeBindings = bindings;\n        }\n\n        return activeBindings;\n    }\n\n    private _createSubRequest(parentRequest: IRequest, target: ITarget) {\n\n        try {\n            let activeBindings = this.getActiveBindings(parentRequest, target);\n\n            if (activeBindings.length === 0) {\n\n                // no matching bindings found\n                let serviceIdentifier = parentRequest.parentContext.kernel.getServiceIdentifierAsString(target.serviceIdentifier);\n                throw new Error(`${ERROR_MSGS.NOT_REGISTERED} ${serviceIdentifier}`);\n\n            } else if (activeBindings.length > 1 && target.isArray() === false) {\n\n                // more than one matching binding found but target is not an array\n                let serviceIdentifier = parentRequest.parentContext.kernel.getServiceIdentifierAsString(target.serviceIdentifier);\n                throw new Error(`${ERROR_MSGS.AMBIGUOUS_MATCH} ${serviceIdentifier}`);\n\n            } else {\n\n                // one ore more than one matching bindings found\n                // when more than 1 matching bindings found target is an array\n                this._createChildRequest(parentRequest, target, activeBindings);\n\n            }\n\n        } catch (error) {\n            if (error instanceof RangeError) {\n                this._throwWhenCircularDependenciesFound(parentRequest.parentContext.plan.rootRequest);\n            } else {\n                throw new Error(error.message);\n            }\n        }\n    }\n\n    private _createChildRequest(parentRequest: IRequest, target: ITarget, bindings: IBinding<any>[]) {\n\n        // Use the only active binding to create a child request\n        let childRequest = parentRequest.addChildRequest(target.serviceIdentifier, bindings, target);\n        let subChildRequest = childRequest;\n\n        bindings.forEach((binding) => {\n\n            if (target.isArray()) {\n                subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);\n            }\n\n            // Only try to plan sub-dependencies when binding type is BindingType.Instance\n            if (binding.type === BindingType.Instance) {\n\n                // Create child requests for sub-dependencies if any\n                let subDependencies = this._getDependencies(binding.implementationType);\n                subDependencies.forEach((d, index) => {\n                    this._createSubRequest(subChildRequest, d);\n                });\n            }\n\n        });\n    }\n\n    private _throwWhenCircularDependenciesFound(\n        request: IRequest, previousServiceIdentifiers: (string|Symbol|INewable<any>)[] = []\n    ) {\n\n        previousServiceIdentifiers.push(request.serviceIdentifier);\n\n        request.childRequests.forEach((childRequest) => {\n\n            let serviceIdentifier = childRequest.serviceIdentifier;\n            if (previousServiceIdentifiers.indexOf(serviceIdentifier) === -1) {\n                if (childRequest.childRequests.length > 0) {\n                    this._throwWhenCircularDependenciesFound(childRequest, previousServiceIdentifiers);\n                } else {\n                    previousServiceIdentifiers.push(serviceIdentifier);\n                }\n            } else {\n                let tailServiceIdentifier = request.parentContext.kernel.getServiceIdentifierAsString(request.serviceIdentifier);\n                throw new Error(`${ERROR_MSGS.CIRCULAR_DEPENDENCY} ${serviceIdentifier} and ${tailServiceIdentifier}`);\n            }\n\n        });\n    }\n\n    private _getDependencies(func: Function): ITarget[] {\n\n        if (func === null) { return []; }\n        let constructorName = (<any>func).name;\n\n        // TypeScript compiler generated annotations\n        let targetsTypes = Reflect.getMetadata(METADATA_KEY.PARAM_TYPES, func);\n\n        // All types resolved bust be annotated with @injectable\n        if (targetsTypes === undefined) {\n            let msg = `${ERROR_MSGS.MISSING_INJECTABLE_ANNOTATION} ${constructorName}.`;\n            throw new Error(msg);\n        }\n\n        // User generated annotations\n        let targetsMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED, func) || [];\n\n        let targets: ITarget[] = [];\n\n        for (let i = 0; i < func.length; i++) {\n\n            let targetType = targetsTypes[i];\n\n            // Create map from array of metadata for faster access to metadata\n            let targetMetadata = targetsMetadata[i.toString()] || [];\n            let targetMetadataMap: any = {};\n            targetMetadata.forEach((m: IMetadata) => {\n                targetMetadataMap[m.key.toString()] = m.value;\n            });\n\n            // user generated metadata\n            let inject: any = targetMetadataMap[METADATA_KEY.INJECT_TAG];\n            let multiInject: any = targetMetadataMap[METADATA_KEY.MULTI_INJECT_TAG];\n            let targetName: any = targetMetadataMap[METADATA_KEY.NAME_TAG];\n\n            // Take type to be injected from user-generated metadata\n            // if not available use compiler-generated metadata\n            targetType = (inject || multiInject) ? (inject || multiInject) : targetType;\n\n            // Types Object and Function are too ambiguous to be resolved\n            // user needs to generate metadata manually for those\n            if (targetType === Object || targetType === Function || targetType === undefined) {\n                let msg = `${ERROR_MSGS.MISSING_INJECT_ANNOTATION} argument ${i} in class ${constructorName}.`;\n                throw new Error(msg);\n            }\n\n            // Create target\n            let target = new Target(targetName, targetType);\n            target.metadata = targetMetadata;\n            targets.push(target);\n\n        }\n\n        // Throw if a derived class does not implement its constructor explicitly\n        // We do this to prevent errors when a base class (parent) has dependencies\n        // and one of the derived classes (children) has no dependencies\n        if (targets.length === 0 && this._baseClassHasDepencencies(func)) {\n            throw new Error(`${ERROR_MSGS.MISSING_EXPLICIT_CONSTRUCTOR} ${constructorName}.`);\n        }\n\n        return targets;\n    }\n\n    private _baseClassHasDepencencies(func: Function): boolean {\n        let baseConstructor = Object.getPrototypeOf(func.prototype).constructor;\n\n        if (baseConstructor !== Object) {\n            let targetsTypes = Reflect.getMetadata(METADATA_KEY.PARAM_TYPES, baseConstructor);\n\n            if (baseConstructor.length > 0 && targetsTypes) {\n                return true;\n            } else {\n                return this._baseClassHasDepencencies(baseConstructor);\n            }\n        } else {\n            return false;\n        }\n    }\n}\n\nexport default Planner;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nclass QueryableString implements IQueryableString {\n\n  private str: string;\n\n  constructor(str: string) {\n    this.str = str;\n  }\n\n  public startsWith(searchString: string): boolean {\n    return this.str.indexOf(searchString) === 0;\n  }\n\n  public endsWith(searchString: string): boolean {\n    let reverseString = \"\";\n    let reverseSearchString = searchString.split(\"\").reverse().join(\"\");\n    reverseString = this.str.split(\"\").reverse().join(\"\");\n    return this.startsWith.call({ str : reverseString }, reverseSearchString);\n  }\n\n  public contains(searchString: string): boolean {\n    return (this.str.indexOf(searchString) !== -1);\n  }\n\n  public equals(compareString: string): boolean {\n    return this.str === compareString;\n  }\n\n  public value(): string {\n    return this.str;\n  }\n\n}\n\nexport default QueryableString;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nclass Request implements IRequest {\n\n        public serviceIdentifier: (string|Symbol|INewable<any>);\n        public parentContext: IContext;\n        public parentRequest: IRequest;\n        public bindings: IBinding<any>[];\n        public childRequests: IRequest[];\n        public target: ITarget;\n\n        public constructor(\n            serviceIdentifier: (string|Symbol|INewable<any>),\n            parentContext: IContext,\n            parentRequest: IRequest,\n            bindings: (IBinding<any>|IBinding<any>[]),\n            target: ITarget = null) {\n\n                this.serviceIdentifier = serviceIdentifier;\n                this.parentContext = parentContext;\n                this.parentRequest = parentRequest;\n                this.target = target;\n                this.childRequests = [];\n                this.bindings = (Array.isArray(bindings) ? bindings : ((bindings) ? [bindings] : []));\n        }\n\n        public addChildRequest(\n            serviceIdentifier: string,\n            bindings: (IBinding<any>|IBinding<any>[]),\n            target: ITarget): IRequest {\n\n                let child = new Request(\n                    serviceIdentifier,\n                    this.parentContext,\n                    this,\n                    bindings,\n                    target\n                );\n                this.childRequests.push(child);\n                return child;\n        }\n}\n\nexport default Request;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport Metadata from \"../planning/metadata\";\nimport QueryableString from \"./queryable_string\";\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\n\nclass Target implements ITarget {\n\n  public serviceIdentifier: (string|Symbol|INewable<any>);\n  public name: QueryableString;\n  public metadata: Array<IMetadata>;\n\n  constructor(name: string, serviceIdentifier: (string|Symbol|INewable<any>), namedOrTagged?: (string|IMetadata)) {\n\n    this.serviceIdentifier = serviceIdentifier;\n    this.name = new QueryableString(name || \"\");\n    this.metadata = new Array<IMetadata>();\n    let metadataItem: IMetadata = null;\n\n    // is named target\n    if (typeof namedOrTagged === \"string\") {\n        metadataItem = new Metadata(METADATA_KEY.NAMED_TAG, namedOrTagged);\n    } else if (namedOrTagged instanceof Metadata) {\n        // is target with metadata\n        metadataItem = namedOrTagged;\n    }\n\n    // target has metadata\n    if (metadataItem !== null) {\n        this.metadata.push(metadataItem);\n    }\n  }\n\n  public hasTag(key: string): boolean {\n    for (let i = 0; i < this.metadata.length; i++) {\n      let m = this.metadata[i];\n      if (m.key === key) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public isArray(): boolean {\n      return this.hasTag(METADATA_KEY.MULTI_INJECT_TAG);\n  }\n\n  public matchesArray(name: string|Symbol|any): boolean {\n    return this.matchesTag(METADATA_KEY.MULTI_INJECT_TAG)(name);\n  }\n\n  public isNamed(): boolean {\n      return this.hasTag(METADATA_KEY.NAMED_TAG);\n  }\n\n  public isTagged(): boolean {\n    if (this.metadata.length > 1) {\n        return true;\n    } else if (this.metadata.length === 1) {\n        // NAMED_TAG is not considered a tagged binding\n        return !this.hasTag(METADATA_KEY.NAMED_TAG);\n    } else {\n        return false;\n    }\n  }\n\n  public matchesNamedTag(name: string): boolean {\n    return this.matchesTag(METADATA_KEY.NAMED_TAG)(name);\n  }\n\n  public matchesTag(key: string) {\n    return (value: any) => {\n        for (let i = 0; i < this.metadata.length; i++) {\n            let m = this.metadata[i];\n            if (m.key === key && m.value === value) {\n                return true;\n            }\n        }\n        return false;\n    };\n  }\n\n}\n\nexport default Target;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingScope from \"../bindings/binding_scope\";\nimport BindingType from \"../bindings/binding_type\";\nimport * as ERROR_MSGS from \"../constants/error_msgs\";\n\nclass Resolver implements IResolver {\n\n    public resolve<Service>(context: IContext): Service {\n        let rootRequest = context.plan.rootRequest;\n        return this._resolve(rootRequest);\n    }\n\n    private _resolve(request: IRequest): any {\n\n        let bindings = request.bindings;\n        let childRequests = request.childRequests;\n\n        if (\n            request.target && request.target.isArray() &&\n            (!request.parentRequest.target || !request.parentRequest.target.matchesArray(request.target.serviceIdentifier))\n        ) {\n\n            // Create an array instead of creating an instance\n            return childRequests.map((childRequest) => { return this._resolve(childRequest); });\n\n        } else {\n\n            let result: any = null;\n            let binding = bindings[0];\n            let isSingleton = binding.scope === BindingScope.Singleton;\n\n            if (isSingleton && binding.activated === true) {\n                return binding.cache;\n            }\n\n            switch (binding.type) {\n\n                case BindingType.ConstantValue:\n                    result = binding.cache;\n                    break;\n\n                case BindingType.DynamicValue:\n                    result = binding.dynamicValue();\n                    break;\n\n                case BindingType.Constructor:\n                    result = binding.implementationType;\n                    break;\n\n                case BindingType.Factory:\n                    result = binding.factory(request.parentContext);\n                    break;\n\n                case BindingType.Provider:\n                    result = binding.provider(request.parentContext);\n                    break;\n\n                case BindingType.Instance:\n\n                    let constr = binding.implementationType;\n\n                    if (childRequests.length > 0) {\n                        let injections = childRequests.map((childRequest) => {\n                            return this._resolve(childRequest);\n                        });\n\n                        result = this._createInstance(constr, injections);\n                    } else {\n                        result = new constr();\n                    }\n\n                    break;\n\n                case BindingType.Invalid:\n                default:\n                    // The user probably created a binding but didn't finish it\n                    // e.g. kernel.bind<T>(\"ISomething\"); missing BindingToSyntax\n                    let serviceIdentifier = request.parentContext.kernel.getServiceIdentifierAsString(request.serviceIdentifier);\n                    throw new Error(`${ERROR_MSGS.INVALID_BINDING_TYPE} ${serviceIdentifier}`);\n            }\n\n            // use activation handler if available\n            if (typeof binding.onActivation === \"function\") {\n                result = binding.onActivation(request.parentContext, result);\n            }\n\n            // store in cache if scope is singleton\n            if (isSingleton) {\n                binding.cache = result;\n                binding.activated = true;\n            }\n\n            return result;\n        }\n\n    }\n\n    private _createInstance(Func: { new(...args: any[]) : any }, injections: Object[]) {\n        return new Func(...injections);\n    }\n\n}\n\nexport default Resolver;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingScope from \"../bindings/binding_scope\";\nimport BindingWhenOnSyntax from \"./binding_when_on_syntax\";\n\nclass BindingInSyntax<T> implements IBindingInSyntax<T> {\n\n    private _binding: IBinding<T>;\n\n    public constructor(binding: IBinding<T>) {\n        this._binding = binding;\n    }\n\n    public inSingletonScope(): IBindingWhenOnSyntax<T> {\n        this._binding.scope = BindingScope.Singleton;\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n}\n\nexport default BindingInSyntax;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingInSyntax from \"./binding_in_syntax\";\nimport BindingWhenSyntax from \"./binding_when_syntax\";\nimport BindingOnSyntax from \"./binding_on_syntax\";\n\nclass BindingInWhenOnSyntax<T> implements IBindingInSyntax<T>, IBindingWhenSyntax<T>, IBindingOnSyntax<T>  {\n\n    private _bindingInSyntax: BindingInSyntax<T>;\n    private _bindingWhenSyntax: IBindingWhenSyntax<T>;\n    private _bindingOnSyntax: IBindingOnSyntax<T>;\n    private _binding: IBinding<T>;\n\n    public constructor(binding: IBinding<T>) {\n        this._binding = binding;\n        this._bindingWhenSyntax = new BindingWhenSyntax<T>(this._binding);\n        this._bindingOnSyntax = new BindingOnSyntax<T>(this._binding);\n        this._bindingInSyntax = new BindingInSyntax<T>(binding);\n    }\n\n    public inSingletonScope(): IBindingWhenOnSyntax<T> {\n        return this._bindingInSyntax.inSingletonScope();\n    }\n\n    public when(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.when(constraint);\n    }\n\n    public whenTargetNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenTargetNamed(name);\n    }\n\n    public whenTargetTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenTargetTagged(tag, value);\n    }\n\n    public whenInjectedInto(parent: (Function|string)): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenInjectedInto(parent);\n    }\n\n    public whenParentNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenParentNamed(name);\n    }\n\n    public whenParentTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenParentTagged(tag, value);\n    }\n\n    public whenAnyAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);\n    }\n\n    public whenNoAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);\n    }\n\n    public whenAnyAncestorNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);\n    }\n\n    public whenAnyAncestorTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);\n    }\n\n    public whenNoAncestorNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorNamed(name);\n    }\n\n    public whenNoAncestorTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);\n    }\n\n    public whenAnyAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);\n    }\n\n    public whenNoAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);\n    }\n\n    public onActivation(handler: (context: IContext, injectable: T) => T): IBindingWhenSyntax<T> {\n        return this._bindingOnSyntax.onActivation(handler);\n    }\n\n}\n\nexport default BindingInWhenOnSyntax;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingWhenSyntax from \"./binding_when_syntax\";\n\nclass BindingOnSyntax<T> implements IBindingOnSyntax<T> {\n\n    private _binding: IBinding<T>;\n\n    public constructor(binding: IBinding<T>) {\n        this._binding = binding;\n    }\n\n    public onActivation(handler: (context: IContext, injectable: T) => T): IBindingWhenSyntax<T> {\n        this._binding.onActivation = handler;\n        return new BindingWhenSyntax<T>(this._binding);\n    }\n\n}\n\nexport default BindingOnSyntax;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingInWhenOnSyntax from \"./binding_in_when_on_syntax\";\nimport BindingWhenOnSyntax from \"./binding_when_on_syntax\";\nimport BindingType from \"../bindings/binding_type\";\n\nclass BindingToSyntax<T> implements IBindingToSyntax<T> {\n\n    private _binding: IBinding<T>;\n\n    public constructor(binding: IBinding<T>) {\n        this._binding = binding;\n    }\n\n    public to(constructor: { new(...args: any[]): T; }): IBindingInWhenOnSyntax<T> {\n        this._binding.type = BindingType.Instance;\n        this._binding.implementationType = constructor;\n        return new BindingInWhenOnSyntax<T>(this._binding);\n    }\n\n    public toConstantValue(value: T): IBindingWhenOnSyntax<T> {\n        this._binding.type = BindingType.ConstantValue;\n        this._binding.cache = value;\n        this._binding.dynamicValue = null;\n        this._binding.implementationType = null;\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n    public toDynamicValue(func: () => T): IBindingWhenOnSyntax<T> {\n        this._binding.type = BindingType.DynamicValue;\n        this._binding.cache = null;\n        this._binding.dynamicValue = func;\n        this._binding.implementationType = null;\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n    public toConstructor<T2>(constructor: INewable<T2>): IBindingWhenOnSyntax<T> {\n        this._binding.type = BindingType.Constructor;\n        this._binding.implementationType = <any>constructor;\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n    public toFactory<T2>(factory: IFactoryCreator<T2>): IBindingWhenOnSyntax<T> {\n        this._binding.type = BindingType.Factory;\n        this._binding.factory = <any>factory;\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n    public toAutoFactory<T2>(serviceIdentifier: (string|Symbol|INewable<T2>)): IBindingWhenOnSyntax<T> {\n        this._binding.type = BindingType.Factory;\n        this._binding.factory = (context) => {\n            return () => {\n                return context.kernel.get<T2>(serviceIdentifier);\n            };\n        };\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n    public toProvider<T2>(provider: IProviderCreator<T2>): IBindingWhenOnSyntax<T> {\n        this._binding.type = BindingType.Provider;\n        this._binding.provider = <any>provider;\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n}\n\nexport default BindingToSyntax;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingWhenSyntax from \"./binding_when_syntax\";\nimport BindingOnSyntax from \"./binding_on_syntax\";\n\nclass BindingWhenOnSyntax<T> implements IBindingWhenSyntax<T>, IBindingOnSyntax<T> {\n\n    private _bindingWhenSyntax: IBindingWhenSyntax<T>;\n    private _bindingOnSyntax: IBindingOnSyntax<T>;\n    private _binding: IBinding<T>;\n\n    public constructor(binding: IBinding<T>) {\n        this._binding = binding;\n        this._bindingWhenSyntax = new BindingWhenSyntax<T>(this._binding);\n        this._bindingOnSyntax = new BindingOnSyntax<T>(this._binding);\n    }\n\n    public when(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.when(constraint);\n    }\n\n    public whenTargetNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenTargetNamed(name);\n    }\n\n    public whenTargetTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenTargetTagged(tag, value);\n    }\n\n    public whenInjectedInto(parent: (Function|string)): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenInjectedInto(parent);\n    }\n\n    public whenParentNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenParentNamed(name);\n    }\n\n    public whenParentTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenParentTagged(tag, value);\n    }\n\n    public whenAnyAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);\n    }\n\n    public whenNoAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);\n    }\n\n    public whenAnyAncestorNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);\n    }\n\n    public whenAnyAncestorTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);\n    }\n\n    public whenNoAncestorNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorNamed(name);\n    }\n\n    public whenNoAncestorTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);\n    }\n\n    public whenAnyAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);\n    }\n\n    public whenNoAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);\n    }\n\n    public onActivation(handler: (context: IContext, injectable: T) => T): IBindingWhenSyntax<T> {\n        return this._bindingOnSyntax.onActivation(handler);\n    }\n\n}\n\nexport default BindingWhenOnSyntax;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingOnSyntax from \"./binding_on_syntax\";\nimport { traverseAncerstors, taggedConstraint, namedConstraint, typeConstraint } from \"./constraint_helpers\";\n\nclass BindingWhenSyntax<T> implements IBindingWhenSyntax<T> {\n\n    private _binding: IBinding<T>;\n\n    public constructor(binding: IBinding<T>) {\n        this._binding = binding;\n    }\n\n    public when(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        this._binding.constraint = constraint;\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenTargetNamed(name: string): IBindingOnSyntax<T> {\n        this._binding.constraint = namedConstraint(name);\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenTargetTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        this._binding.constraint = taggedConstraint(tag)(value);\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenInjectedInto(parent: (Function|string)): IBindingOnSyntax<T> {\n        this._binding.constraint = (request: IRequest) => {\n            return typeConstraint(parent)(request.parentRequest);\n        };\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenParentNamed(name: string): IBindingOnSyntax<T> {\n        this._binding.constraint = (request: IRequest) => {\n            return namedConstraint(name)(request.parentRequest);\n        };\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenParentTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        this._binding.constraint = (request: IRequest) => {\n            return taggedConstraint(tag)(value)(request.parentRequest);\n        };\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenAnyAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T> {\n        this._binding.constraint = (request: IRequest) => {\n            return traverseAncerstors(request, typeConstraint(ancestor));\n        };\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenNoAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T> {\n        this._binding.constraint = (request: IRequest) => {\n            return !traverseAncerstors(request, typeConstraint(ancestor));\n        };\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenAnyAncestorNamed(name: string): IBindingOnSyntax<T> {\n\n        this._binding.constraint = (request: IRequest) => {\n            return traverseAncerstors(request, namedConstraint(name));\n        };\n\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenNoAncestorNamed(name: string): IBindingOnSyntax<T> {\n\n        this._binding.constraint = (request: IRequest) => {\n            return !traverseAncerstors(request, namedConstraint(name));\n        };\n\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenAnyAncestorTagged(tag: string, value: any): IBindingOnSyntax<T> {\n\n        this._binding.constraint = (request: IRequest) => {\n            return traverseAncerstors(request, taggedConstraint(tag)(value));\n        };\n\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenNoAncestorTagged(tag: string, value: any): IBindingOnSyntax<T> {\n\n        this._binding.constraint = (request: IRequest) => {\n            return !traverseAncerstors(request, taggedConstraint(tag)(value));\n        };\n\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenAnyAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n\n        this._binding.constraint = (request: IRequest) => {\n            return traverseAncerstors(request, constraint);\n        };\n\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenNoAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n\n        this._binding.constraint = (request: IRequest) => {\n            return !traverseAncerstors(request, constraint);\n        };\n\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n}\n\nexport default BindingWhenSyntax;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\n\nlet traverseAncerstors = (request: IRequest, constraint: (request: IRequest) => boolean): boolean => {\n    let parent = request.parentRequest;\n    if (parent !== null) {\n        return constraint(parent) ? true : traverseAncerstors(parent, constraint);\n    } else {\n        return false;\n    }\n};\n\n// This helpers use currying to help you to generate constraints\n\nlet taggedConstraint = (key: string) => (value: any) => (request: IRequest) => {\n    return request.target.matchesTag(key)(value);\n};\n\nlet namedConstraint = taggedConstraint(METADATA_KEY.NAMED_TAG);\n\nlet typeConstraint = (type: (Function|string)) => (request: IRequest) => {\n\n    // Using index 0 because constraints are applied \n    // to one binding at a time (see Planner class)\n    let binding = request.bindings[0];\n\n    if (typeof type === \"string\") {\n        let serviceIdentifier = binding.serviceIdentifier;\n        return serviceIdentifier === type;\n    } else {\n        let constructor = request.bindings[0].implementationType;\n        return type === constructor;\n    }\n};\n\nexport { traverseAncerstors, taggedConstraint, namedConstraint, typeConstraint };\n"],"sourceRoot":"/source/"}