{"version":3,"sources":["inversify.min.js","node_modules/browser-pack/_prelude.js","src/annotation/decorator_utils.ts","src/annotation/inject.ts","src/annotation/injectable.ts","src/annotation/multi_inject.ts","src/annotation/named.ts","src/annotation/param_name.ts","src/annotation/tagged.ts","src/bindings/binding.ts","src/bindings/binding_count.ts","src/bindings/binding_scope.ts","src/bindings/binding_type.ts","src/constants/error_msgs.ts","src/constants/metadata_keys.ts","src/inversify.ts","src/kernel/kernel.ts","src/kernel/key_value_pair.ts","src/kernel/lookup.ts","src/planning/context.ts","src/planning/metadata.ts","src/planning/plan.ts","src/planning/planner.ts","src/planning/queryable_string.ts","src/planning/request.ts","src/planning/target.ts","src/resolution/resolver.ts","src/syntax/binding_in_syntax.ts","src/syntax/binding_in_when_on_syntax.ts","src/syntax/binding_on_syntax.ts","src/syntax/binding_to_syntax.ts","src/syntax/binding_when_on_syntax.ts","src/syntax/binding_when_syntax.ts","src/syntax/constraint_helpers.ts"],"names":["f","exports","module","define","amd","g","window","global","self","this","inversify","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"tagParameter","target","targetKey","index","metadata","paramsMetadata","undefined","ERROR_MSGS","INVALID_DECORATOR_OPERATION","Reflect","hasOwnMetadata","METADATA_KEY","TAGGED","getMetadata","paramMetadata","toString","Array","isArray","m","key","DUPLICATED_METADATA","push","defineMetadata","_decorate","decorators","decorate","_param","paramIndex","decorator","parameterIndex","../constants/error_msgs","../constants/metadata_keys",2,"inject","serviceIdentifier","metadata_1","INJECT_TAG","decorator_utils_1","Object","defineProperty","value","../planning/metadata","./decorator_utils",3,"injectable","PARAM_TYPES","ERRORS_MSGS","DUPLICATED_INJECTABLE_DECORATOR","types","DESIGN_PARAM_TYPES",4,"multiInject","MULTI_INJECT_TAG",5,"named","name","NAMED_TAG",6,"paramName","NAME_TAG",7,"tagged","metadataKey","metadataValue",8,"binding_scope_1","binding_type_1","Binding","activated","scope","Transient","type","Invalid","constraint","request","implementationType","cache","factory","provider","onActivation","./binding_scope","./binding_type",9,"BindingCount",10,"BindingScope",11,"BindingType",12,"NULL_ARGUMENT","KEY_NOT_FOUND","AMBIGUOUS_MATCH","CANNOT_UNBIND","NOT_REGISTERED","MISSING_INJECTABLE_ANNOTATION","MISSING_INJECT_ANNOTATION","CIRCULAR_DEPENDENCY","NOT_IMPLEMENTED","INVALID_BINDING_TYPE","MISSING_EXPLICIT_CONSTRUCTOR",13,14,"kernel_1","Kernel","injectable_1","tagged_1","named_1","inject_1","multi_inject_1","param_name_1","constraint_helpers_1","traverseAncerstors","taggedConstraint","namedConstraint","typeConstraint","./annotation/decorator_utils","./annotation/inject","./annotation/injectable","./annotation/multi_inject","./annotation/named","./annotation/param_name","./annotation/tagged","./kernel/kernel","./syntax/constraint_helpers",15,"binding_count_1","binding_1","lookup_1","planner_1","resolver_1","binding_to_syntax_1","target_1","request_1","_planner","_resolver","_bindingDictionary","_middleware","prototype","load","_this","modules","_i","arguments","forEach","applyMiddleware","middlewares","reverse","reduce","prev","curr","resolve","bind","binding","add","unbind","remove","unbindAll","get","_get","getNamed","getTagged","getAll","bindings","getBindings","NoBindingsAvailable","OnlyOneBindingAvailable","MultipleBindingsAvailable","map","_planAndResolve","getServiceIdentifierAsString","_serviceIdentifier","createContext","getActiveBindings","context","createPlan","../bindings/binding","../bindings/binding_count","../planning/planner","../planning/request","../planning/target","../resolution/resolver","../syntax/binding_to_syntax","./lookup",16,"KeyValuePair",17,"key_value_pair_1","Lookup","_dictionary","getIndexByKey","splice","hasKey","keyValuePair","./key_value_pair",18,"Context","kernel","addPlan","plan",19,"Metadata",20,"Plan","parentContext","rootRequest",21,"plan_1","context_1","Planner","dependencies","_getDependencies","dependency","_createSubRequest","_kernel","parentRequest","activeBindings","filter","_createChildRequest","error","RangeError","message","_throwWhenCircularDependenciesFound","childRequest","addChildRequest","subChildRequest","Instance","subDependencies","d","previousServiceIdentifiers","childRequests","indexOf","tailServiceIdentifier","func","constructorName","targetsTypes","msg","targetsMetadata","targets","_loop_1","targetType","targetMetadata","targetMetadataMap","targetName","Function","_baseClassHasDepencencies","baseConstructor","getPrototypeOf","constructor","../bindings/binding_type","./context","./plan","./request","./target",22,"QueryableString","str","startsWith","searchString","endsWith","reverseString","reverseSearchString","split","join","contains","equals","compareString",23,"Request","child",24,"queryable_string_1","Target","namedOrTagged","metadataItem","hasTag","matchesArray","matchesTag","isNamed","isTagged","matchesNamedTag","./queryable_string",25,"Resolver","_resolve","result","isSingleton","Singleton","Value","Constructor","Factory","Provider","constr","injections","_createInstance","Func","apply","concat","../bindings/binding_scope",26,"binding_when_on_syntax_1","BindingInSyntax","_binding","inSingletonScope","./binding_when_on_syntax",27,"binding_in_syntax_1","binding_when_syntax_1","binding_on_syntax_1","BindingInWhenOnSyntax","_bindingWhenSyntax","_bindingOnSyntax","_bindingInSyntax","when","whenTargetNamed","whenTargetTagged","tag","whenInjectedInto","parent","whenParentNamed","whenParentTagged","whenAnyAncestorIs","ancestor","whenNoAncestorIs","whenAnyAncestorNamed","whenAnyAncestorTagged","whenNoAncestorNamed","whenNoAncestorTagged","whenAnyAncestorMatches","whenNoAncestorMatches","handler","./binding_in_syntax","./binding_on_syntax","./binding_when_syntax",28,"BindingOnSyntax",29,"binding_in_when_on_syntax_1","BindingToSyntax","to","toValue","toConstructor","toFactory","toAutoFactory","toProvider","./binding_in_when_on_syntax",30,"BindingWhenOnSyntax",31,"BindingWhenSyntax","./constraint_helpers",32],"mappings":"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","file":"inversify.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.inversify = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nvar ERROR_MSGS = require(\"../constants/error_msgs\");\nfunction tagParameter(target, targetKey, index, metadata) {\n    var paramsMetadata = null;\n    if (targetKey !== undefined) {\n        throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);\n    }\n    if (Reflect.hasOwnMetadata(METADATA_KEY.TAGGED, target) !== true) {\n        paramsMetadata = {};\n    }\n    else {\n        paramsMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED, target);\n    }\n    var paramMetadata = paramsMetadata[index.toString()];\n    if (Array.isArray(paramMetadata) !== true) {\n        paramMetadata = [];\n    }\n    else {\n        for (var i = 0; i < paramMetadata.length; i++) {\n            var m = paramMetadata[i];\n            if (m.key === metadata.key) {\n                throw new Error(ERROR_MSGS.DUPLICATED_METADATA + \" \" + m.key);\n            }\n        }\n    }\n    paramMetadata.push(metadata);\n    paramsMetadata[index.toString()] = paramMetadata;\n    Reflect.defineMetadata(METADATA_KEY.TAGGED, paramsMetadata, target);\n    return target;\n}\nexports.tagParameter = tagParameter;\nfunction _decorate(decorators, target) {\n    Reflect.decorate(decorators, target);\n}\nfunction _param(paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); };\n}\nfunction decorate(decorator, target, parameterIndex) {\n    if (typeof parameterIndex === \"number\") {\n        _decorate([_param(parameterIndex, decorator)], target);\n    }\n    else {\n        _decorate([decorator], target);\n    }\n}\nexports.decorate = decorate;\n\n},{\"../constants/error_msgs\":12,\"../constants/metadata_keys\":13}],2:[function(require,module,exports){\n\"use strict\";\nvar metadata_1 = require(\"../planning/metadata\");\nvar decorator_utils_1 = require(\"./decorator_utils\");\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nfunction inject(serviceIdentifier) {\n    return function (target, targetKey, index) {\n        var metadata = new metadata_1.default(METADATA_KEY.INJECT_TAG, serviceIdentifier);\n        return decorator_utils_1.tagParameter(target, targetKey, index, metadata);\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = inject;\n\n},{\"../constants/metadata_keys\":13,\"../planning/metadata\":19,\"./decorator_utils\":1}],3:[function(require,module,exports){\n\"use strict\";\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nvar ERRORS_MSGS = require(\"../constants/error_msgs\");\nfunction injectable() {\n    return function (target) {\n        if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target) === true) {\n            throw new Error(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);\n        }\n        var types = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, target) || [];\n        Reflect.defineMetadata(METADATA_KEY.PARAM_TYPES, types, target);\n        return target;\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = injectable;\n\n},{\"../constants/error_msgs\":12,\"../constants/metadata_keys\":13}],4:[function(require,module,exports){\n\"use strict\";\nvar metadata_1 = require(\"../planning/metadata\");\nvar decorator_utils_1 = require(\"./decorator_utils\");\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nfunction multiInject(serviceIdentifier) {\n    return function (target, targetKey, index) {\n        var metadata = new metadata_1.default(METADATA_KEY.MULTI_INJECT_TAG, serviceIdentifier);\n        return decorator_utils_1.tagParameter(target, targetKey, index, metadata);\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = multiInject;\n\n},{\"../constants/metadata_keys\":13,\"../planning/metadata\":19,\"./decorator_utils\":1}],5:[function(require,module,exports){\n\"use strict\";\nvar metadata_1 = require(\"../planning/metadata\");\nvar decorator_utils_1 = require(\"./decorator_utils\");\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nfunction named(name) {\n    return function (target, targetKey, index) {\n        var metadata = new metadata_1.default(METADATA_KEY.NAMED_TAG, name);\n        return decorator_utils_1.tagParameter(target, targetKey, index, metadata);\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = named;\n\n},{\"../constants/metadata_keys\":13,\"../planning/metadata\":19,\"./decorator_utils\":1}],6:[function(require,module,exports){\n\"use strict\";\nvar metadata_1 = require(\"../planning/metadata\");\nvar decorator_utils_1 = require(\"./decorator_utils\");\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nfunction paramName(name) {\n    return function (target, targetKey, index) {\n        var metadata = new metadata_1.default(METADATA_KEY.NAME_TAG, name);\n        return decorator_utils_1.tagParameter(target, targetKey, index, metadata);\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = paramName;\n\n},{\"../constants/metadata_keys\":13,\"../planning/metadata\":19,\"./decorator_utils\":1}],7:[function(require,module,exports){\n\"use strict\";\nvar metadata_1 = require(\"../planning/metadata\");\nvar decorator_utils_1 = require(\"./decorator_utils\");\nfunction tagged(metadataKey, metadataValue) {\n    return function (target, targetKey, index) {\n        var metadata = new metadata_1.default(metadataKey, metadataValue);\n        return decorator_utils_1.tagParameter(target, targetKey, index, metadata);\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = tagged;\n\n},{\"../planning/metadata\":19,\"./decorator_utils\":1}],8:[function(require,module,exports){\n\"use strict\";\nvar binding_scope_1 = require(\"./binding_scope\");\nvar binding_type_1 = require(\"./binding_type\");\nvar Binding = (function () {\n    function Binding(serviceIdentifier) {\n        this.activated = false;\n        this.serviceIdentifier = serviceIdentifier;\n        this.scope = binding_scope_1.default.Transient;\n        this.type = binding_type_1.default.Invalid;\n        this.constraint = function (request) { return true; };\n        this.implementationType = null;\n        this.cache = null;\n        this.factory = null;\n        this.provider = null;\n        this.onActivation = null;\n    }\n    return Binding;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Binding;\n\n},{\"./binding_scope\":10,\"./binding_type\":11}],9:[function(require,module,exports){\n\"use strict\";\nvar BindingCount;\n(function (BindingCount) {\n    BindingCount[BindingCount[\"NoBindingsAvailable\"] = 0] = \"NoBindingsAvailable\";\n    BindingCount[BindingCount[\"OnlyOneBindingAvailable\"] = 1] = \"OnlyOneBindingAvailable\";\n    BindingCount[BindingCount[\"MultipleBindingsAvailable\"] = 2] = \"MultipleBindingsAvailable\";\n})(BindingCount || (BindingCount = {}));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BindingCount;\n\n},{}],10:[function(require,module,exports){\n\"use strict\";\nvar BindingScope;\n(function (BindingScope) {\n    BindingScope[BindingScope[\"Transient\"] = 0] = \"Transient\";\n    BindingScope[BindingScope[\"Singleton\"] = 1] = \"Singleton\";\n})(BindingScope || (BindingScope = {}));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BindingScope;\n\n},{}],11:[function(require,module,exports){\n\"use strict\";\nvar BindingType;\n(function (BindingType) {\n    BindingType[BindingType[\"Invalid\"] = 0] = \"Invalid\";\n    BindingType[BindingType[\"Instance\"] = 1] = \"Instance\";\n    BindingType[BindingType[\"Value\"] = 2] = \"Value\";\n    BindingType[BindingType[\"Constructor\"] = 3] = \"Constructor\";\n    BindingType[BindingType[\"Factory\"] = 4] = \"Factory\";\n    BindingType[BindingType[\"Provider\"] = 5] = \"Provider\";\n})(BindingType || (BindingType = {}));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BindingType;\n\n},{}],12:[function(require,module,exports){\n\"use strict\";\nexports.DUPLICATED_INJECTABLE_DECORATOR = \"Cannot apply @injectable decorator multiple times.\";\nexports.DUPLICATED_METADATA = \"Metadadata key was used more than once in a parameter:\";\nexports.NULL_ARGUMENT = \"NULL argument\";\nexports.KEY_NOT_FOUND = \"Key Not Found\";\nexports.AMBIGUOUS_MATCH = \"Ambiguous match found for serviceIdentifier:\";\nexports.CANNOT_UNBIND = \"Could not unbind serviceIdentifier:\";\nexports.NOT_REGISTERED = \"No bindigns found for serviceIdentifier:\";\nexports.MISSING_INJECTABLE_ANNOTATION = \"Missing required @injectable annotation in:\";\nexports.MISSING_INJECT_ANNOTATION = \"Missing required @inject or @multiInject annotation in:\";\nexports.CIRCULAR_DEPENDENCY = \"Circular dependency found between services:\";\nexports.NOT_IMPLEMENTED = \"Sorry, this feature is not fully implemented yet.\";\nexports.INVALID_BINDING_TYPE = \"Invalid binding type:\";\nexports.MISSING_EXPLICIT_CONSTRUCTOR = \"Derived class must explicitly declare its constructor:\";\nexports.INVALID_DECORATOR_OPERATION = \"The @inject @multiInject @tagged and @named decorators \" +\n    \"must be applied to the parameters of a constructor.\";\n\n},{}],13:[function(require,module,exports){\n\"use strict\";\nexports.NAMED_TAG = \"named\";\nexports.NAME_TAG = \"name\";\nexports.INJECT_TAG = \"inject\";\nexports.MULTI_INJECT_TAG = \"multi_inject\";\nexports.TAGGED = \"inversify:tagged\";\nexports.PARAM_TYPES = \"inversify:paramtypes\";\nexports.DESIGN_PARAM_TYPES = \"design:paramtypes\";\n\n},{}],14:[function(require,module,exports){\n\"use strict\";\nvar kernel_1 = require(\"./kernel/kernel\");\nexports.Kernel = kernel_1.default;\nvar injectable_1 = require(\"./annotation/injectable\");\nexports.injectable = injectable_1.default;\nvar tagged_1 = require(\"./annotation/tagged\");\nexports.tagged = tagged_1.default;\nvar named_1 = require(\"./annotation/named\");\nexports.named = named_1.default;\nvar inject_1 = require(\"./annotation/inject\");\nexports.inject = inject_1.default;\nvar multi_inject_1 = require(\"./annotation/multi_inject\");\nexports.multiInject = multi_inject_1.default;\nvar param_name_1 = require(\"./annotation/param_name\");\nexports.paramName = param_name_1.default;\nvar decorator_utils_1 = require(\"./annotation/decorator_utils\");\nexports.decorate = decorator_utils_1.decorate;\nvar constraint_helpers_1 = require(\"./syntax/constraint_helpers\");\nexports.traverseAncerstors = constraint_helpers_1.traverseAncerstors;\nexports.taggedConstraint = constraint_helpers_1.taggedConstraint;\nexports.namedConstraint = constraint_helpers_1.namedConstraint;\nexports.typeConstraint = constraint_helpers_1.typeConstraint;\n\n},{\"./annotation/decorator_utils\":1,\"./annotation/inject\":2,\"./annotation/injectable\":3,\"./annotation/multi_inject\":4,\"./annotation/named\":5,\"./annotation/param_name\":6,\"./annotation/tagged\":7,\"./kernel/kernel\":15,\"./syntax/constraint_helpers\":32}],15:[function(require,module,exports){\n\"use strict\";\nvar binding_count_1 = require(\"../bindings/binding_count\");\nvar binding_1 = require(\"../bindings/binding\");\nvar lookup_1 = require(\"./lookup\");\nvar planner_1 = require(\"../planning/planner\");\nvar resolver_1 = require(\"../resolution/resolver\");\nvar ERROR_MSGS = require(\"../constants/error_msgs\");\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nvar binding_to_syntax_1 = require(\"../syntax/binding_to_syntax\");\nvar metadata_1 = require(\"../planning/metadata\");\nvar target_1 = require(\"../planning/target\");\nvar request_1 = require(\"../planning/request\");\nvar Kernel = (function () {\n    function Kernel() {\n        this._planner = new planner_1.default();\n        this._resolver = new resolver_1.default();\n        this._bindingDictionary = new lookup_1.default();\n        this._middleware = null;\n    }\n    Kernel.prototype.load = function () {\n        var _this = this;\n        var modules = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            modules[_i - 0] = arguments[_i];\n        }\n        modules.forEach(function (module) { module(_this); });\n    };\n    Kernel.prototype.applyMiddleware = function () {\n        var middlewares = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            middlewares[_i - 0] = arguments[_i];\n        }\n        this._middleware = middlewares.reverse().reduce(function (prev, curr) {\n            return curr(prev);\n        }, this._resolver.resolve.bind(this._resolver));\n    };\n    Kernel.prototype.bind = function (serviceIdentifier) {\n        var binding = new binding_1.default(serviceIdentifier);\n        this._bindingDictionary.add(serviceIdentifier, binding);\n        return new binding_to_syntax_1.default(binding);\n    };\n    Kernel.prototype.unbind = function (serviceIdentifier) {\n        try {\n            this._bindingDictionary.remove(serviceIdentifier);\n        }\n        catch (e) {\n            throw new Error(ERROR_MSGS.CANNOT_UNBIND + \" \" + serviceIdentifier);\n        }\n    };\n    Kernel.prototype.unbindAll = function () {\n        this._bindingDictionary = new lookup_1.default();\n    };\n    Kernel.prototype.get = function (serviceIdentifier) {\n        return this._get(serviceIdentifier, null);\n    };\n    Kernel.prototype.getNamed = function (serviceIdentifier, named) {\n        return this.getTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);\n    };\n    Kernel.prototype.getTagged = function (serviceIdentifier, key, value) {\n        var metadata = new metadata_1.default(key, value);\n        var target = new target_1.default(null, serviceIdentifier, metadata);\n        return this._get(serviceIdentifier, target);\n    };\n    Kernel.prototype.getAll = function (serviceIdentifier) {\n        var _this = this;\n        var bindings = this._planner.getBindings(this, serviceIdentifier);\n        switch (bindings.length) {\n            case binding_count_1.default.NoBindingsAvailable:\n                throw new Error(ERROR_MSGS.NOT_REGISTERED + \" \" + serviceIdentifier);\n            case binding_count_1.default.OnlyOneBindingAvailable:\n            case binding_count_1.default.MultipleBindingsAvailable:\n            default:\n                return bindings.map(function (binding) {\n                    return _this._planAndResolve(binding, null);\n                });\n        }\n    };\n    Kernel.prototype.getServiceIdentifierAsString = function (serviceIdentifier) {\n        var type = typeof serviceIdentifier;\n        if (type === \"function\") {\n            var _serviceIdentifier = serviceIdentifier;\n            return _serviceIdentifier.name;\n        }\n        else if (type === \"symbol\") {\n            return serviceIdentifier.toString();\n        }\n        else {\n            var _serviceIdentifier = serviceIdentifier;\n            return _serviceIdentifier;\n        }\n    };\n    Kernel.prototype._get = function (serviceIdentifier, target) {\n        var bindings = this._planner.getBindings(this, serviceIdentifier);\n        if (target !== null) {\n            var request = new request_1.default(serviceIdentifier, this._planner.createContext(this), null, bindings, target);\n            bindings = this._planner.getActiveBindings(request, target);\n        }\n        if (bindings.length === binding_count_1.default.NoBindingsAvailable) {\n            throw new Error(ERROR_MSGS.NOT_REGISTERED + \" \" + serviceIdentifier);\n        }\n        else if (bindings.length === binding_count_1.default.OnlyOneBindingAvailable) {\n            return this._planAndResolve(bindings[0], target);\n        }\n        else {\n            throw new Error(ERROR_MSGS.AMBIGUOUS_MATCH + \" \" + serviceIdentifier);\n        }\n    };\n    Kernel.prototype._planAndResolve = function (binding, target) {\n        var context = this._planner.createContext(this);\n        this._planner.createPlan(context, binding, target);\n        return (this._middleware !== null) ? this._middleware(context) : this._resolver.resolve(context);\n    };\n    return Kernel;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Kernel;\n\n},{\"../bindings/binding\":8,\"../bindings/binding_count\":9,\"../constants/error_msgs\":12,\"../constants/metadata_keys\":13,\"../planning/metadata\":19,\"../planning/planner\":21,\"../planning/request\":23,\"../planning/target\":24,\"../resolution/resolver\":25,\"../syntax/binding_to_syntax\":29,\"./lookup\":17}],16:[function(require,module,exports){\n\"use strict\";\nvar KeyValuePair = (function () {\n    function KeyValuePair(serviceIdentifier, value) {\n        this.serviceIdentifier = serviceIdentifier;\n        this.value = new Array();\n        this.value.push(value);\n    }\n    return KeyValuePair;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = KeyValuePair;\n\n},{}],17:[function(require,module,exports){\n\"use strict\";\nvar key_value_pair_1 = require(\"./key_value_pair\");\nvar ERROR_MSGS = require(\"../constants/error_msgs\");\nvar Lookup = (function () {\n    function Lookup() {\n        this._dictionary = new Array();\n    }\n    Lookup.prototype.add = function (serviceIdentifier, value) {\n        if (serviceIdentifier === null || serviceIdentifier === undefined) {\n            throw new Error(ERROR_MSGS.NULL_ARGUMENT);\n        }\n        ;\n        if (value === null || value === undefined) {\n            throw new Error(ERROR_MSGS.NULL_ARGUMENT);\n        }\n        ;\n        var index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            this._dictionary[index].value.push(value);\n        }\n        else {\n            this._dictionary.push(new key_value_pair_1.default(serviceIdentifier, value));\n        }\n    };\n    Lookup.prototype.get = function (serviceIdentifier) {\n        if (serviceIdentifier === null || serviceIdentifier === undefined) {\n            throw new Error(ERROR_MSGS.NULL_ARGUMENT);\n        }\n        var index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            return this._dictionary[index].value;\n        }\n        else {\n            throw new Error(ERROR_MSGS.KEY_NOT_FOUND);\n        }\n    };\n    Lookup.prototype.remove = function (serviceIdentifier) {\n        if (serviceIdentifier === null || serviceIdentifier === undefined) {\n            throw new Error(ERROR_MSGS.NULL_ARGUMENT);\n        }\n        var index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            this._dictionary.splice(index, 1);\n        }\n        else {\n            throw new Error(ERROR_MSGS.KEY_NOT_FOUND);\n        }\n    };\n    Lookup.prototype.hasKey = function (serviceIdentifier) {\n        if (serviceIdentifier === null || serviceIdentifier === undefined) {\n            throw new Error(ERROR_MSGS.NULL_ARGUMENT);\n        }\n        var index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    Lookup.prototype.getIndexByKey = function (serviceIdentifier) {\n        var index = -1;\n        for (var i = 0; i < this._dictionary.length; i++) {\n            var keyValuePair = this._dictionary[i];\n            if (keyValuePair.serviceIdentifier === serviceIdentifier) {\n                index = i;\n            }\n        }\n        return index;\n    };\n    return Lookup;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Lookup;\n\n},{\"../constants/error_msgs\":12,\"./key_value_pair\":16}],18:[function(require,module,exports){\n\"use strict\";\nvar Context = (function () {\n    function Context(kernel) {\n        this.kernel = kernel;\n    }\n    Context.prototype.addPlan = function (plan) {\n        this.plan = plan;\n    };\n    return Context;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Context;\n\n},{}],19:[function(require,module,exports){\n\"use strict\";\nvar Metadata = (function () {\n    function Metadata(key, value) {\n        this.key = key;\n        this.value = value;\n    }\n    return Metadata;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Metadata;\n\n},{}],20:[function(require,module,exports){\n\"use strict\";\nvar Plan = (function () {\n    function Plan(parentContext, rootRequest) {\n        this.parentContext = parentContext;\n        this.rootRequest = rootRequest;\n    }\n    return Plan;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Plan;\n\n},{}],21:[function(require,module,exports){\n\"use strict\";\nvar plan_1 = require(\"./plan\");\nvar context_1 = require(\"./context\");\nvar request_1 = require(\"./request\");\nvar target_1 = require(\"./target\");\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nvar ERROR_MSGS = require(\"../constants/error_msgs\");\nvar binding_type_1 = require(\"../bindings/binding_type\");\nvar Planner = (function () {\n    function Planner() {\n    }\n    Planner.prototype.createContext = function (kernel) {\n        return new context_1.default(kernel);\n    };\n    Planner.prototype.createPlan = function (context, binding, target) {\n        var _this = this;\n        var rootRequest = new request_1.default(binding.serviceIdentifier, context, null, binding, target);\n        var plan = new plan_1.default(context, rootRequest);\n        context.addPlan(plan);\n        var dependencies = this._getDependencies(binding.implementationType);\n        dependencies.forEach(function (dependency) { _this._createSubRequest(rootRequest, dependency); });\n        return plan;\n    };\n    Planner.prototype.getBindings = function (kernel, serviceIdentifier) {\n        var bindings = [];\n        var _kernel = kernel;\n        var _bindingDictionary = _kernel._bindingDictionary;\n        if (_bindingDictionary.hasKey(serviceIdentifier)) {\n            bindings = _bindingDictionary.get(serviceIdentifier);\n        }\n        return bindings;\n    };\n    Planner.prototype.getActiveBindings = function (parentRequest, target) {\n        var bindings = this.getBindings(parentRequest.parentContext.kernel, target.serviceIdentifier);\n        var activeBindings = [];\n        if (bindings.length > 1 && target.isArray() === false) {\n            activeBindings = bindings.filter(function (binding) {\n                var request = new request_1.default(binding.serviceIdentifier, parentRequest.parentContext, parentRequest, binding, target);\n                return binding.constraint(request);\n            });\n        }\n        else {\n            activeBindings = bindings;\n        }\n        return activeBindings;\n    };\n    Planner.prototype._createSubRequest = function (parentRequest, target) {\n        try {\n            var activeBindings = this.getActiveBindings(parentRequest, target);\n            if (activeBindings.length === 0) {\n                var serviceIdentifier = parentRequest.parentContext.kernel.getServiceIdentifierAsString(target.serviceIdentifier);\n                throw new Error(ERROR_MSGS.NOT_REGISTERED + \" \" + serviceIdentifier);\n            }\n            else if (activeBindings.length > 1 && target.isArray() === false) {\n                var serviceIdentifier = parentRequest.parentContext.kernel.getServiceIdentifierAsString(target.serviceIdentifier);\n                throw new Error(ERROR_MSGS.AMBIGUOUS_MATCH + \" \" + serviceIdentifier);\n            }\n            else {\n                this._createChildRequest(parentRequest, target, activeBindings);\n            }\n        }\n        catch (error) {\n            if (error instanceof RangeError) {\n                this._throwWhenCircularDependenciesFound(parentRequest.parentContext.plan.rootRequest);\n            }\n            else {\n                throw new Error(error.message);\n            }\n        }\n    };\n    Planner.prototype._createChildRequest = function (parentRequest, target, bindings) {\n        var _this = this;\n        var childRequest = parentRequest.addChildRequest(target.serviceIdentifier, bindings, target);\n        var subChildRequest = childRequest;\n        bindings.forEach(function (binding) {\n            if (target.isArray()) {\n                subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);\n            }\n            if (binding.type === binding_type_1.default.Instance) {\n                var subDependencies = _this._getDependencies(binding.implementationType);\n                subDependencies.forEach(function (d, index) {\n                    _this._createSubRequest(subChildRequest, d);\n                });\n            }\n        });\n    };\n    Planner.prototype._throwWhenCircularDependenciesFound = function (request, previousServiceIdentifiers) {\n        var _this = this;\n        if (previousServiceIdentifiers === void 0) { previousServiceIdentifiers = []; }\n        previousServiceIdentifiers.push(request.serviceIdentifier);\n        request.childRequests.forEach(function (childRequest) {\n            var serviceIdentifier = childRequest.serviceIdentifier;\n            if (previousServiceIdentifiers.indexOf(serviceIdentifier) === -1) {\n                if (childRequest.childRequests.length > 0) {\n                    _this._throwWhenCircularDependenciesFound(childRequest, previousServiceIdentifiers);\n                }\n                else {\n                    previousServiceIdentifiers.push(serviceIdentifier);\n                }\n            }\n            else {\n                var tailServiceIdentifier = request.parentContext.kernel.getServiceIdentifierAsString(request.serviceIdentifier);\n                throw new Error(ERROR_MSGS.CIRCULAR_DEPENDENCY + \" \" + serviceIdentifier + \" and \" + tailServiceIdentifier);\n            }\n        });\n    };\n    Planner.prototype._getDependencies = function (func) {\n        if (func === null) {\n            return [];\n        }\n        var constructorName = func.name;\n        var targetsTypes = Reflect.getMetadata(METADATA_KEY.PARAM_TYPES, func);\n        if (targetsTypes === undefined) {\n            var msg = ERROR_MSGS.MISSING_INJECTABLE_ANNOTATION + \" \" + constructorName + \".\";\n            throw new Error(msg);\n        }\n        var targetsMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED, func) || [];\n        var targets = [];\n        var _loop_1 = function(i) {\n            var targetType = targetsTypes[i];\n            var targetMetadata = targetsMetadata[i.toString()] || [];\n            var targetMetadataMap = {};\n            targetMetadata.forEach(function (m) {\n                targetMetadataMap[m.key.toString()] = m.value;\n            });\n            var inject = targetMetadataMap[METADATA_KEY.INJECT_TAG];\n            var multiInject = targetMetadataMap[METADATA_KEY.MULTI_INJECT_TAG];\n            var targetName = targetMetadataMap[METADATA_KEY.NAME_TAG];\n            targetType = (inject || multiInject) ? (inject || multiInject) : targetType;\n            if (targetType === Object || targetType === Function || targetType === undefined) {\n                var msg = ERROR_MSGS.MISSING_INJECT_ANNOTATION + \" argument \" + i + \" in class \" + constructorName + \".\";\n                throw new Error(msg);\n            }\n            var target = new target_1.default(targetName, targetType);\n            target.metadata = targetMetadata;\n            targets.push(target);\n        };\n        for (var i = 0; i < func.length; i++) {\n            _loop_1(i);\n        }\n        if (targets.length === 0 && this._baseClassHasDepencencies(func)) {\n            throw new Error(ERROR_MSGS.MISSING_EXPLICIT_CONSTRUCTOR + \" \" + constructorName + \".\");\n        }\n        return targets;\n    };\n    Planner.prototype._baseClassHasDepencencies = function (func) {\n        var baseConstructor = Object.getPrototypeOf(func.prototype).constructor;\n        if (baseConstructor !== Object) {\n            if (baseConstructor.length > 0) {\n                return true;\n            }\n            else {\n                return this._baseClassHasDepencencies(baseConstructor);\n            }\n        }\n        else {\n            return false;\n        }\n    };\n    return Planner;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Planner;\n\n},{\"../bindings/binding_type\":11,\"../constants/error_msgs\":12,\"../constants/metadata_keys\":13,\"./context\":18,\"./plan\":20,\"./request\":23,\"./target\":24}],22:[function(require,module,exports){\n\"use strict\";\nvar QueryableString = (function () {\n    function QueryableString(str) {\n        this.str = str;\n    }\n    QueryableString.prototype.startsWith = function (searchString) {\n        return this.str.indexOf(searchString) === 0;\n    };\n    QueryableString.prototype.endsWith = function (searchString) {\n        var reverseString = \"\";\n        var reverseSearchString = searchString.split(\"\").reverse().join(\"\");\n        reverseString = this.str.split(\"\").reverse().join(\"\");\n        return this.startsWith.call({ str: reverseString }, reverseSearchString);\n    };\n    QueryableString.prototype.contains = function (searchString) {\n        return (this.str.indexOf(searchString) !== -1);\n    };\n    QueryableString.prototype.equals = function (compareString) {\n        return this.str === compareString;\n    };\n    QueryableString.prototype.value = function () {\n        return this.str;\n    };\n    return QueryableString;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = QueryableString;\n\n},{}],23:[function(require,module,exports){\n\"use strict\";\nvar Request = (function () {\n    function Request(serviceIdentifier, parentContext, parentRequest, bindings, target) {\n        if (target === void 0) { target = null; }\n        this.serviceIdentifier = serviceIdentifier;\n        this.parentContext = parentContext;\n        this.parentRequest = parentRequest;\n        this.target = target;\n        this.childRequests = [];\n        this.bindings = (Array.isArray(bindings) ? bindings : ((bindings) ? [bindings] : []));\n    }\n    Request.prototype.addChildRequest = function (serviceIdentifier, bindings, target) {\n        var child = new Request(serviceIdentifier, this.parentContext, this, bindings, target);\n        this.childRequests.push(child);\n        return child;\n    };\n    return Request;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Request;\n\n},{}],24:[function(require,module,exports){\n\"use strict\";\nvar metadata_1 = require(\"../planning/metadata\");\nvar queryable_string_1 = require(\"./queryable_string\");\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nvar Target = (function () {\n    function Target(name, serviceIdentifier, namedOrTagged) {\n        this.serviceIdentifier = serviceIdentifier;\n        this.name = new queryable_string_1.default(name || \"\");\n        this.metadata = new Array();\n        var metadataItem = null;\n        if (typeof namedOrTagged === \"string\") {\n            metadataItem = new metadata_1.default(METADATA_KEY.NAMED_TAG, namedOrTagged);\n        }\n        else if (namedOrTagged instanceof metadata_1.default) {\n            metadataItem = namedOrTagged;\n        }\n        if (metadataItem !== null) {\n            this.metadata.push(metadataItem);\n        }\n    }\n    Target.prototype.hasTag = function (key) {\n        for (var i = 0; i < this.metadata.length; i++) {\n            var m = this.metadata[i];\n            if (m.key === key) {\n                return true;\n            }\n        }\n        return false;\n    };\n    Target.prototype.isArray = function () {\n        return this.hasTag(METADATA_KEY.MULTI_INJECT_TAG);\n    };\n    Target.prototype.matchesArray = function (name) {\n        return this.matchesTag(METADATA_KEY.MULTI_INJECT_TAG)(name);\n    };\n    Target.prototype.isNamed = function () {\n        return this.hasTag(METADATA_KEY.NAMED_TAG);\n    };\n    Target.prototype.isTagged = function () {\n        if (this.metadata.length > 1) {\n            return true;\n        }\n        else if (this.metadata.length === 1) {\n            return !this.hasTag(METADATA_KEY.NAMED_TAG);\n        }\n        else {\n            return false;\n        }\n    };\n    Target.prototype.matchesNamedTag = function (name) {\n        return this.matchesTag(METADATA_KEY.NAMED_TAG)(name);\n    };\n    Target.prototype.matchesTag = function (key) {\n        var _this = this;\n        return function (value) {\n            for (var i = 0; i < _this.metadata.length; i++) {\n                var m = _this.metadata[i];\n                if (m.key === key && m.value === value) {\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    return Target;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Target;\n\n},{\"../constants/metadata_keys\":13,\"../planning/metadata\":19,\"./queryable_string\":22}],25:[function(require,module,exports){\n\"use strict\";\nvar binding_scope_1 = require(\"../bindings/binding_scope\");\nvar binding_type_1 = require(\"../bindings/binding_type\");\nvar ERROR_MSGS = require(\"../constants/error_msgs\");\nvar Resolver = (function () {\n    function Resolver() {\n    }\n    Resolver.prototype.resolve = function (context) {\n        var rootRequest = context.plan.rootRequest;\n        return this._resolve(rootRequest);\n    };\n    Resolver.prototype._resolve = function (request) {\n        var _this = this;\n        var bindings = request.bindings;\n        var childRequests = request.childRequests;\n        if (request.target && request.target.isArray() &&\n            (!request.parentRequest.target || !request.parentRequest.target.matchesArray(request.target.serviceIdentifier))) {\n            return childRequests.map(function (childRequest) { return _this._resolve(childRequest); });\n        }\n        else {\n            var result = null;\n            var binding = bindings[0];\n            var isSingleton = binding.scope === binding_scope_1.default.Singleton;\n            if (isSingleton && binding.activated === true) {\n                return binding.cache;\n            }\n            switch (binding.type) {\n                case binding_type_1.default.Value:\n                    result = binding.cache;\n                    break;\n                case binding_type_1.default.Constructor:\n                    result = binding.implementationType;\n                    break;\n                case binding_type_1.default.Factory:\n                    result = binding.factory(request.parentContext);\n                    break;\n                case binding_type_1.default.Provider:\n                    result = binding.provider(request.parentContext);\n                    break;\n                case binding_type_1.default.Instance:\n                    var constr = binding.implementationType;\n                    if (childRequests.length > 0) {\n                        var injections = childRequests.map(function (childRequest) {\n                            return _this._resolve(childRequest);\n                        });\n                        result = this._createInstance(constr, injections);\n                    }\n                    else {\n                        result = new constr();\n                    }\n                    break;\n                case binding_type_1.default.Invalid:\n                default:\n                    var serviceIdentifier = request.parentContext.kernel.getServiceIdentifierAsString(request.serviceIdentifier);\n                    throw new Error(ERROR_MSGS.INVALID_BINDING_TYPE + \" \" + serviceIdentifier);\n            }\n            if (typeof binding.onActivation === \"function\") {\n                result = binding.onActivation(request.parentContext, result);\n            }\n            if (isSingleton) {\n                binding.cache = result;\n                binding.activated = true;\n            }\n            return result;\n        }\n    };\n    Resolver.prototype._createInstance = function (Func, injections) {\n        return new (Func.bind.apply(Func, [void 0].concat(injections)))();\n    };\n    return Resolver;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Resolver;\n\n},{\"../bindings/binding_scope\":10,\"../bindings/binding_type\":11,\"../constants/error_msgs\":12}],26:[function(require,module,exports){\n\"use strict\";\nvar binding_scope_1 = require(\"../bindings/binding_scope\");\nvar binding_when_on_syntax_1 = require(\"./binding_when_on_syntax\");\nvar BindingInSyntax = (function () {\n    function BindingInSyntax(binding) {\n        this._binding = binding;\n    }\n    BindingInSyntax.prototype.inSingletonScope = function () {\n        this._binding.scope = binding_scope_1.default.Singleton;\n        return new binding_when_on_syntax_1.default(this._binding);\n    };\n    return BindingInSyntax;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BindingInSyntax;\n\n},{\"../bindings/binding_scope\":10,\"./binding_when_on_syntax\":30}],27:[function(require,module,exports){\n\"use strict\";\nvar binding_in_syntax_1 = require(\"./binding_in_syntax\");\nvar binding_when_syntax_1 = require(\"./binding_when_syntax\");\nvar binding_on_syntax_1 = require(\"./binding_on_syntax\");\nvar BindingInWhenOnSyntax = (function () {\n    function BindingInWhenOnSyntax(binding) {\n        this._binding = binding;\n        this._bindingWhenSyntax = new binding_when_syntax_1.default(this._binding);\n        this._bindingOnSyntax = new binding_on_syntax_1.default(this._binding);\n        this._bindingInSyntax = new binding_in_syntax_1.default(binding);\n    }\n    BindingInWhenOnSyntax.prototype.inSingletonScope = function () {\n        return this._bindingInSyntax.inSingletonScope();\n    };\n    BindingInWhenOnSyntax.prototype.when = function (constraint) {\n        return this._bindingWhenSyntax.when(constraint);\n    };\n    BindingInWhenOnSyntax.prototype.whenTargetNamed = function (name) {\n        return this._bindingWhenSyntax.whenTargetNamed(name);\n    };\n    BindingInWhenOnSyntax.prototype.whenTargetTagged = function (tag, value) {\n        return this._bindingWhenSyntax.whenTargetTagged(tag, value);\n    };\n    BindingInWhenOnSyntax.prototype.whenInjectedInto = function (parent) {\n        return this._bindingWhenSyntax.whenInjectedInto(parent);\n    };\n    BindingInWhenOnSyntax.prototype.whenParentNamed = function (name) {\n        return this._bindingWhenSyntax.whenParentNamed(name);\n    };\n    BindingInWhenOnSyntax.prototype.whenParentTagged = function (tag, value) {\n        return this._bindingWhenSyntax.whenParentTagged(tag, value);\n    };\n    BindingInWhenOnSyntax.prototype.whenAnyAncestorIs = function (ancestor) {\n        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);\n    };\n    BindingInWhenOnSyntax.prototype.whenNoAncestorIs = function (ancestor) {\n        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);\n    };\n    BindingInWhenOnSyntax.prototype.whenAnyAncestorNamed = function (name) {\n        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);\n    };\n    BindingInWhenOnSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {\n        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);\n    };\n    BindingInWhenOnSyntax.prototype.whenNoAncestorNamed = function (name) {\n        return this._bindingWhenSyntax.whenNoAncestorNamed(name);\n    };\n    BindingInWhenOnSyntax.prototype.whenNoAncestorTagged = function (tag, value) {\n        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);\n    };\n    BindingInWhenOnSyntax.prototype.whenAnyAncestorMatches = function (constraint) {\n        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);\n    };\n    BindingInWhenOnSyntax.prototype.whenNoAncestorMatches = function (constraint) {\n        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);\n    };\n    BindingInWhenOnSyntax.prototype.onActivation = function (handler) {\n        return this._bindingOnSyntax.onActivation(handler);\n    };\n    return BindingInWhenOnSyntax;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BindingInWhenOnSyntax;\n\n},{\"./binding_in_syntax\":26,\"./binding_on_syntax\":28,\"./binding_when_syntax\":31}],28:[function(require,module,exports){\n\"use strict\";\nvar binding_when_syntax_1 = require(\"./binding_when_syntax\");\nvar BindingOnSyntax = (function () {\n    function BindingOnSyntax(binding) {\n        this._binding = binding;\n    }\n    BindingOnSyntax.prototype.onActivation = function (handler) {\n        this._binding.onActivation = handler;\n        return new binding_when_syntax_1.default(this._binding);\n    };\n    return BindingOnSyntax;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BindingOnSyntax;\n\n},{\"./binding_when_syntax\":31}],29:[function(require,module,exports){\n\"use strict\";\nvar binding_in_when_on_syntax_1 = require(\"./binding_in_when_on_syntax\");\nvar binding_when_on_syntax_1 = require(\"./binding_when_on_syntax\");\nvar binding_type_1 = require(\"../bindings/binding_type\");\nvar BindingToSyntax = (function () {\n    function BindingToSyntax(binding) {\n        this._binding = binding;\n    }\n    BindingToSyntax.prototype.to = function (constructor) {\n        this._binding.type = binding_type_1.default.Instance;\n        this._binding.implementationType = constructor;\n        return new binding_in_when_on_syntax_1.default(this._binding);\n    };\n    BindingToSyntax.prototype.toValue = function (value) {\n        this._binding.type = binding_type_1.default.Value;\n        this._binding.cache = value;\n        this._binding.implementationType = null;\n        return new binding_when_on_syntax_1.default(this._binding);\n    };\n    BindingToSyntax.prototype.toConstructor = function (constructor) {\n        this._binding.type = binding_type_1.default.Constructor;\n        this._binding.implementationType = constructor;\n        return new binding_when_on_syntax_1.default(this._binding);\n    };\n    BindingToSyntax.prototype.toFactory = function (factory) {\n        this._binding.type = binding_type_1.default.Factory;\n        this._binding.factory = factory;\n        return new binding_when_on_syntax_1.default(this._binding);\n    };\n    BindingToSyntax.prototype.toAutoFactory = function (serviceIdentifier) {\n        this._binding.type = binding_type_1.default.Factory;\n        this._binding.factory = function (context) {\n            return function () {\n                return context.kernel.get(serviceIdentifier);\n            };\n        };\n        return new binding_when_on_syntax_1.default(this._binding);\n    };\n    BindingToSyntax.prototype.toProvider = function (provider) {\n        this._binding.type = binding_type_1.default.Provider;\n        this._binding.provider = provider;\n        return new binding_when_on_syntax_1.default(this._binding);\n    };\n    return BindingToSyntax;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BindingToSyntax;\n\n},{\"../bindings/binding_type\":11,\"./binding_in_when_on_syntax\":27,\"./binding_when_on_syntax\":30}],30:[function(require,module,exports){\n\"use strict\";\nvar binding_when_syntax_1 = require(\"./binding_when_syntax\");\nvar binding_on_syntax_1 = require(\"./binding_on_syntax\");\nvar BindingWhenOnSyntax = (function () {\n    function BindingWhenOnSyntax(binding) {\n        this._binding = binding;\n        this._bindingWhenSyntax = new binding_when_syntax_1.default(this._binding);\n        this._bindingOnSyntax = new binding_on_syntax_1.default(this._binding);\n    }\n    BindingWhenOnSyntax.prototype.when = function (constraint) {\n        return this._bindingWhenSyntax.when(constraint);\n    };\n    BindingWhenOnSyntax.prototype.whenTargetNamed = function (name) {\n        return this._bindingWhenSyntax.whenTargetNamed(name);\n    };\n    BindingWhenOnSyntax.prototype.whenTargetTagged = function (tag, value) {\n        return this._bindingWhenSyntax.whenTargetTagged(tag, value);\n    };\n    BindingWhenOnSyntax.prototype.whenInjectedInto = function (parent) {\n        return this._bindingWhenSyntax.whenInjectedInto(parent);\n    };\n    BindingWhenOnSyntax.prototype.whenParentNamed = function (name) {\n        return this._bindingWhenSyntax.whenParentNamed(name);\n    };\n    BindingWhenOnSyntax.prototype.whenParentTagged = function (tag, value) {\n        return this._bindingWhenSyntax.whenParentTagged(tag, value);\n    };\n    BindingWhenOnSyntax.prototype.whenAnyAncestorIs = function (ancestor) {\n        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);\n    };\n    BindingWhenOnSyntax.prototype.whenNoAncestorIs = function (ancestor) {\n        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);\n    };\n    BindingWhenOnSyntax.prototype.whenAnyAncestorNamed = function (name) {\n        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);\n    };\n    BindingWhenOnSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {\n        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);\n    };\n    BindingWhenOnSyntax.prototype.whenNoAncestorNamed = function (name) {\n        return this._bindingWhenSyntax.whenNoAncestorNamed(name);\n    };\n    BindingWhenOnSyntax.prototype.whenNoAncestorTagged = function (tag, value) {\n        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);\n    };\n    BindingWhenOnSyntax.prototype.whenAnyAncestorMatches = function (constraint) {\n        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);\n    };\n    BindingWhenOnSyntax.prototype.whenNoAncestorMatches = function (constraint) {\n        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);\n    };\n    BindingWhenOnSyntax.prototype.onActivation = function (handler) {\n        return this._bindingOnSyntax.onActivation(handler);\n    };\n    return BindingWhenOnSyntax;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BindingWhenOnSyntax;\n\n},{\"./binding_on_syntax\":28,\"./binding_when_syntax\":31}],31:[function(require,module,exports){\n\"use strict\";\nvar binding_on_syntax_1 = require(\"./binding_on_syntax\");\nvar constraint_helpers_1 = require(\"./constraint_helpers\");\nvar BindingWhenSyntax = (function () {\n    function BindingWhenSyntax(binding) {\n        this._binding = binding;\n    }\n    BindingWhenSyntax.prototype.when = function (constraint) {\n        this._binding.constraint = constraint;\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenTargetNamed = function (name) {\n        this._binding.constraint = constraint_helpers_1.namedConstraint(name);\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenTargetTagged = function (tag, value) {\n        this._binding.constraint = constraint_helpers_1.taggedConstraint(tag)(value);\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenInjectedInto = function (parent) {\n        this._binding.constraint = function (request) {\n            return constraint_helpers_1.typeConstraint(parent)(request.parentRequest);\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenParentNamed = function (name) {\n        this._binding.constraint = function (request) {\n            return constraint_helpers_1.namedConstraint(name)(request.parentRequest);\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenParentTagged = function (tag, value) {\n        this._binding.constraint = function (request) {\n            return constraint_helpers_1.taggedConstraint(tag)(value)(request.parentRequest);\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenAnyAncestorIs = function (ancestor) {\n        this._binding.constraint = function (request) {\n            return constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.typeConstraint(ancestor));\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenNoAncestorIs = function (ancestor) {\n        this._binding.constraint = function (request) {\n            return !constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.typeConstraint(ancestor));\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenAnyAncestorNamed = function (name) {\n        this._binding.constraint = function (request) {\n            return constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.namedConstraint(name));\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenNoAncestorNamed = function (name) {\n        this._binding.constraint = function (request) {\n            return !constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.namedConstraint(name));\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {\n        this._binding.constraint = function (request) {\n            return constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.taggedConstraint(tag)(value));\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenNoAncestorTagged = function (tag, value) {\n        this._binding.constraint = function (request) {\n            return !constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.taggedConstraint(tag)(value));\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenAnyAncestorMatches = function (constraint) {\n        this._binding.constraint = function (request) {\n            return constraint_helpers_1.traverseAncerstors(request, constraint);\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    BindingWhenSyntax.prototype.whenNoAncestorMatches = function (constraint) {\n        this._binding.constraint = function (request) {\n            return !constraint_helpers_1.traverseAncerstors(request, constraint);\n        };\n        return new binding_on_syntax_1.default(this._binding);\n    };\n    return BindingWhenSyntax;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BindingWhenSyntax;\n\n},{\"./binding_on_syntax\":28,\"./constraint_helpers\":32}],32:[function(require,module,exports){\n\"use strict\";\nvar METADATA_KEY = require(\"../constants/metadata_keys\");\nvar traverseAncerstors = function (request, constraint) {\n    var parent = request.parentRequest;\n    if (parent !== null) {\n        return constraint(parent) ? true : traverseAncerstors(parent, constraint);\n    }\n    else {\n        return false;\n    }\n};\nexports.traverseAncerstors = traverseAncerstors;\nvar taggedConstraint = function (key) { return function (value) { return function (request) {\n    return request.target.matchesTag(key)(value);\n}; }; };\nexports.taggedConstraint = taggedConstraint;\nvar namedConstraint = taggedConstraint(METADATA_KEY.NAMED_TAG);\nexports.namedConstraint = namedConstraint;\nvar typeConstraint = function (type) { return function (request) {\n    var binding = request.bindings[0];\n    if (typeof type === \"string\") {\n        var serviceIdentifier = binding.serviceIdentifier;\n        return serviceIdentifier === type;\n    }\n    else {\n        var constructor = request.bindings[0].implementationType;\n        return type === constructor;\n    }\n}; };\nexports.typeConstraint = typeConstraint;\n\n},{\"../constants/metadata_keys\":13}]},{},[14])(14)\n});\n\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\nimport * as ERROR_MSGS from \"../constants/error_msgs\";\n\ninterface IReflectResult {\n    [key: string]: IMetadata[];\n}\n\nfunction tagParameter(target: any, targetKey: string, index: number, metadata: IMetadata) {\n\n    let paramsMetadata: IReflectResult = null;\n\n    // this decorator can be used in a constructor not a method\n    if (targetKey !== undefined) {\n        throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);\n    }\n\n    // read metadata if avalible\n    if (Reflect.hasOwnMetadata(METADATA_KEY.TAGGED, target) !== true) {\n        paramsMetadata = {};\n    } else {\n        paramsMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED, target);\n    }\n\n    // get metadata for the decorated parameter by its index\n    let paramMetadata: IMetadata[] = paramsMetadata[index.toString()];\n    if (Array.isArray(paramMetadata) !== true) {\n        paramMetadata = [];\n    } else {\n        for (let i = 0; i < paramMetadata.length; i++) {\n            let m: IMetadata = paramMetadata[i];\n            if (m.key === metadata.key) {\n                throw new Error(`${ERROR_MSGS.DUPLICATED_METADATA} ${m.key}`);\n            }\n        }\n    }\n\n    // set metadata\n    paramMetadata.push(metadata);\n    paramsMetadata[index.toString()] = paramMetadata;\n    Reflect.defineMetadata(METADATA_KEY.TAGGED, paramsMetadata, target);\n    return target;\n}\n\nfunction _decorate(decorators: ClassDecorator[], target: any): void {\n    Reflect.decorate(decorators, target);\n}\n\nfunction _param(paramIndex: number, decorator: ParameterDecorator): ClassDecorator {\n    return function (target: any, key?: string) { decorator(target, key, paramIndex); };\n}\n\n// Allows VanillaJS developers to use decorators:\n// decorate(injectable(\"IFoo\", \"IBar\"), FooBar);\n// decorate(paramNames(\"foo\", \"bar\"), FooBar);\n// decorate(named(\"foo\"), FooBar, 0);\n// decorate(tagged(\"bar\"), FooBar, 1);\nfunction decorate(\n    decorator: (ClassDecorator|ParameterDecorator),\n    target: any,\n    parameterIndex?: number): void {\n\n    if (typeof parameterIndex === \"number\") {\n        _decorate([_param(parameterIndex, <ParameterDecorator>decorator)], target);\n    } else {\n        _decorate([<ClassDecorator>decorator], target);\n    }\n}\n\nexport { decorate, tagParameter };\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\r\n\r\nimport Metadata from \"../planning/metadata\";\r\nimport { tagParameter } from \"./decorator_utils\";\r\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\r\n\r\n// Used to declare types to be injected not available at runtime\r\nfunction inject(serviceIdentifier: (string|Symbol)) {\r\n  return function(target: any, targetKey: string, index: number) {\r\n    let metadata = new Metadata(METADATA_KEY.INJECT_TAG, serviceIdentifier);\r\n    return tagParameter(target, targetKey, index, metadata);\r\n  };\r\n}\r\n\r\nexport default inject;\r\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\nimport * as ERRORS_MSGS from \"../constants/error_msgs\";\n\nfunction injectable() {\n  return function(target: any) {\n\n    if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target) === true) {\n      throw new Error(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);\n    }\n\n    let types = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, target) || [];\n    Reflect.defineMetadata(METADATA_KEY.PARAM_TYPES, types, target);\n\n    return target;\n  };\n}\n\nexport default injectable;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport Metadata from \"../planning/metadata\";\nimport { tagParameter } from \"./decorator_utils\";\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\n\nfunction multiInject(serviceIdentifier: (string|Symbol)) {\n  return function(target: any, targetKey: string, index: number) {\n    let metadata = new Metadata(METADATA_KEY.MULTI_INJECT_TAG, serviceIdentifier);\n    return tagParameter(target, targetKey, index, metadata);\n  };\n}\n\nexport default multiInject;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\r\n\r\nimport Metadata from \"../planning/metadata\";\r\nimport { tagParameter } from \"./decorator_utils\";\r\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\r\n\r\n// Used to add named metadata which is used to resolve name-based contextual bindings.\r\nfunction named(name: string) {\r\n  return function(target: any, targetKey: string, index: number) {\r\n    let metadata = new Metadata(METADATA_KEY.NAMED_TAG, name);\r\n    return tagParameter(target, targetKey, index, metadata);\r\n  };\r\n}\r\n\r\nexport default named;\r\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport Metadata from \"../planning/metadata\";\nimport { tagParameter } from \"./decorator_utils\";\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\n\nfunction paramName(name: string) {\n  return function(target: any, targetKey: string, index: number) {\n    let metadata = new Metadata(METADATA_KEY.NAME_TAG, name);\n    return tagParameter(target, targetKey, index, metadata);\n  };\n}\n\nexport default paramName;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport Metadata from \"../planning/metadata\";\nimport { tagParameter } from \"./decorator_utils\";\n\n// Used to add custom metadata which is used to resolve metadata-based contextual bindings.\nfunction tagged(metadataKey: string, metadataValue: any) {\n    return function(target: any, targetKey: string, index: number) {\n        let metadata = new Metadata(metadataKey, metadataValue);\n        return tagParameter(target, targetKey, index, metadata);\n    };\n}\n\nexport default tagged;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\n// Binding\n// -----------\n\n// A type binding (or just a binding) is a mapping between a service type\n// (an interface), and an implementation type to be used to satisfy such\n// a service requirement.\n\nimport BindingScope from \"./binding_scope\";\nimport BindingType from \"./binding_type\";\n\nclass Binding<T> implements IBinding<T> {\n\n    // Determines wether the bindings has been already activated\n    // The activation action takes place when an instance is resolved\n    // If the scope is singleton it only happens once\n    public activated: boolean;\n\n    // A runtime identifier because at runtime we don't have interfaces\n    public serviceIdentifier: (string|Symbol|INewable<T>);\n\n    // The constructor of a class which must implement T\n    public implementationType: INewable<T>;\n\n    // Cache used to allow singleton scope and BindingType.Value bindings\n    public cache: T;\n\n    // The scope mode to be used\n    public scope: BindingScope;\n\n    // The kind of binding\n    public type: BindingType;\n\n    // A factory method used in BindingType.Factory bindings\n    public factory: IFactoryCreator<T>;\n\n    // An async factory method used in BindingType.Provider bindings\n    public provider: IProviderCreator<T>;\n\n    // A constraint used to limit the contexts in which this binding is applicable\n    public constraint: (request: IRequest) => boolean;\n\n    // On activation handler (invoked just before an instance is added to cache and injected)\n    public onActivation: (context: IContext, injectable: T) => T;\n\n    constructor(serviceIdentifier: (string|Symbol|INewable<T>)) {\n        this.activated = false;\n        this.serviceIdentifier = serviceIdentifier;\n        this.scope = BindingScope.Transient;\n        this.type = BindingType.Invalid;\n        this.constraint = (request: IRequest) => { return true; };\n        this.implementationType = null;\n        this.cache = null;\n        this.factory = null;\n        this.provider = null;\n        this.onActivation = null;\n    }\n}\n\nexport default Binding;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nenum BindingCount {\n    NoBindingsAvailable = 0,\n    OnlyOneBindingAvailable = 1,\n    MultipleBindingsAvailable = 2\n}\n\nexport default BindingCount;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nenum BindingScope {\n  Transient = 0,\n  Singleton = 1\n}\n\nexport default BindingScope;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nenum BindingType {\n  Invalid = 0,\n  Instance = 1,\n  Value = 2,\n  Constructor = 3,\n  Factory = 4,\n  Provider = 5\n}\n\nexport default BindingType;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nexport const DUPLICATED_INJECTABLE_DECORATOR = \"Cannot apply @injectable decorator multiple times.\";\nexport const DUPLICATED_METADATA = \"Metadadata key was used more than once in a parameter:\";\nexport const NULL_ARGUMENT = \"NULL argument\";\nexport const KEY_NOT_FOUND = \"Key Not Found\";\nexport const AMBIGUOUS_MATCH = \"Ambiguous match found for serviceIdentifier:\";\nexport const CANNOT_UNBIND = \"Could not unbind serviceIdentifier:\";\nexport const NOT_REGISTERED = \"No bindigns found for serviceIdentifier:\";\nexport const MISSING_INJECTABLE_ANNOTATION = \"Missing required @injectable annotation in:\";\nexport const MISSING_INJECT_ANNOTATION = \"Missing required @inject or @multiInject annotation in:\";\nexport const CIRCULAR_DEPENDENCY = \"Circular dependency found between services:\";\nexport const NOT_IMPLEMENTED = \"Sorry, this feature is not fully implemented yet.\";\nexport const INVALID_BINDING_TYPE = \"Invalid binding type:\";\nexport const MISSING_EXPLICIT_CONSTRUCTOR = \"Derived class must explicitly declare its constructor:\";\nexport const INVALID_DECORATOR_OPERATION = \"The @inject @multiInject @tagged and @named decorators \" +\n    \"must be applied to the parameters of a constructor.\";\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\n// Used for named bindings\nexport const NAMED_TAG = \"named\";\n\n// The name of the target at design time\nexport const NAME_TAG = \"name\";\n\n// The type of the binding at design time\nexport const INJECT_TAG = \"inject\";\n\n// The type of the binding at design type for multi-injections\nexport const MULTI_INJECT_TAG = \"multi_inject\";\n\n// used to store tags\nexport const TAGGED = \"inversify:tagged\";\n\n// used to store types to be injected\nexport const PARAM_TYPES = \"inversify:paramtypes\";\n\n// used to access design time types\nexport const DESIGN_PARAM_TYPES = \"design:paramtypes\";\n","///<reference path=\"./interfaces/interfaces.d.ts\" />\n\n// Inversify\n// ---------\n\n// The Inversify main file, the library entry point.\n\nimport Kernel from \"./kernel/kernel\";\nimport injectable from \"./annotation/injectable\";\nimport tagged from \"./annotation/tagged\";\nimport named from \"./annotation/named\";\nimport inject from \"./annotation/inject\";\nimport multiInject from \"./annotation/multi_inject\";\nimport paramName from \"./annotation/param_name\";\nimport { decorate } from \"./annotation/decorator_utils\";\nimport { traverseAncerstors, taggedConstraint, namedConstraint, typeConstraint } from \"./syntax/constraint_helpers\";\n\nexport { Kernel };\nexport { decorate };\nexport { injectable };\nexport { tagged };\nexport { named };\nexport { inject };\nexport { multiInject };\nexport { paramName };\nexport { traverseAncerstors };\nexport { taggedConstraint };\nexport { namedConstraint };\nexport { typeConstraint };\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\n// Kernel\n// ------\n\n// Inversify is a lightweight pico container for TypeScript\n// and JavaScript apps.\n\n// A pico container uses a class constructor to identify and\n// inject its dependencies. For this to work, the class needs\n// to declare a constructor that includes everything it\n// needs injected.\n\n// In order to resolve a depencency, the pico container needs\n// to be told which implementation type (classes) to associate\n// with each service type (interfaces).\n\nimport BindingCount from \"../bindings/binding_count\";\nimport Binding from \"../bindings/binding\";\nimport Lookup from \"./lookup\";\nimport Planner from \"../planning/planner\";\nimport Resolver from \"../resolution/resolver\";\nimport * as ERROR_MSGS from \"../constants/error_msgs\";\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\nimport BindingToSyntax from \"../syntax/binding_to_syntax\";\nimport Metadata from \"../planning/metadata\";\nimport Target from \"../planning/target\";\nimport Request from \"../planning/request\";\n\nclass Kernel implements IKernel {\n\n    private _planner: IPlanner;\n    private _resolver: IResolver;\n    private _middleware: (context: IContext) => any;\n    private _bindingDictionary: ILookup<IBinding<any>>;\n\n    // Initialize private properties\n    public constructor() {\n        this._planner = new Planner();\n        this._resolver = new Resolver();\n        this._bindingDictionary = new Lookup<IBinding<any>>();\n        this._middleware = null;\n    }\n\n    public load(...modules: IKernelModule[]): void {\n        modules.forEach((module) => { module(this); });\n    }\n\n    public applyMiddleware(...middlewares: IMiddleware[]): void {\n        this._middleware = middlewares.reverse().reduce((prev, curr) => {\n            return curr(prev);\n        }, this._resolver.resolve.bind(this._resolver));\n    }\n\n    // Regiters a type binding\n    public bind<T>(serviceIdentifier: (string|Symbol|INewable<T>)): IBindingToSyntax<T> {\n        let binding = new Binding<T>(serviceIdentifier);\n        this._bindingDictionary.add(serviceIdentifier, binding);\n        return new BindingToSyntax<T>(binding);\n    }\n\n    // Removes a type binding from the registry by its key\n    public unbind(serviceIdentifier: (string|Symbol|any)): void {\n        try {\n            this._bindingDictionary.remove(serviceIdentifier);\n        } catch (e) {\n            throw new Error(`${ERROR_MSGS.CANNOT_UNBIND} ${serviceIdentifier}`);\n        }\n    }\n\n    // Removes all the type bindings from the registry\n    public unbindAll(): void {\n        this._bindingDictionary = new Lookup<IBinding<any>>();\n    }\n\n    // Resolves a dependency by its runtime identifier\n    // The runtime identifier must be associated with only one binding\n    // use getAll when the runtime identifier is associated with multiple bindings\n    public get<T>(serviceIdentifier: (string|Symbol|INewable<T>)): T {\n        return this._get<T>(serviceIdentifier, null);\n    }\n\n    public getNamed<T>(serviceIdentifier: (string|Symbol|INewable<T>), named: string): T {\n        return this.getTagged<T>(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);\n    }\n\n    public getTagged<T>(serviceIdentifier: (string|Symbol|INewable<T>), key: string, value: any): T {\n        let metadata = new Metadata(key, value);\n        let target = new Target(null, serviceIdentifier, metadata);\n        return this._get<T>(serviceIdentifier, target);\n    }\n\n    // Resolves a dependency by its runtime identifier\n    // The runtime identifier can be associated with one or multiple bindings\n    public getAll<T>(serviceIdentifier: (string|Symbol|INewable<T>)): T[] {\n\n        let bindings = this._planner.getBindings<T>(this, serviceIdentifier);\n\n        switch (bindings.length) {\n\n            // CASE 1: There are no bindings\n            case BindingCount.NoBindingsAvailable:\n                throw new Error(`${ERROR_MSGS.NOT_REGISTERED} ${serviceIdentifier}`);\n\n            // CASE 2: There is AT LEAST 1 binding    \n            case BindingCount.OnlyOneBindingAvailable:\n            case BindingCount.MultipleBindingsAvailable:\n            default:\n                return bindings.map((binding) => {\n                    return this._planAndResolve<T>(binding, null);\n                });\n        }\n    }\n\n    public getServiceIdentifierAsString(serviceIdentifier: (string|Symbol|INewable<any>)): string {\n        let type = typeof serviceIdentifier;\n        if (type === \"function\") {\n            let _serviceIdentifier: any = serviceIdentifier;\n            return _serviceIdentifier.name;\n        } else if (type === \"symbol\") {\n            return serviceIdentifier.toString();\n        } else { // string\n            let _serviceIdentifier: any = serviceIdentifier;\n            return _serviceIdentifier;\n        }\n    }\n\n    private _get<T>(serviceIdentifier: (string|Symbol|INewable<T>), target: ITarget): T {\n\n        let bindings = this._planner.getBindings<T>(this, serviceIdentifier);\n\n        // Filter bindings using the target and the binding constraints\n        if (target !== null) {\n\n            let request = new Request(\n                serviceIdentifier,\n                this._planner.createContext(this),\n                null,\n                bindings,\n                target\n            );\n\n            bindings = this._planner.getActiveBindings(request, target);\n        }\n\n        if (bindings.length === BindingCount.NoBindingsAvailable) {\n\n            // CASE 1: There are no bindings\n            throw new Error(`${ERROR_MSGS.NOT_REGISTERED} ${serviceIdentifier}`);\n\n        } else if (bindings.length === BindingCount.OnlyOneBindingAvailable) {\n\n            // CASE 2: There is 1 binding\n            return this._planAndResolve<T>(bindings[0], target);\n\n        } else {\n\n            // CASE 3: There are multiple bindings\n            throw new Error(`${ERROR_MSGS.AMBIGUOUS_MATCH} ${serviceIdentifier}`);\n\n        }\n\n    }\n\n    // Generates an executes a resolution plan\n    private _planAndResolve<T>(binding: IBinding<T>, target: ITarget): T {\n\n        // STEP 1: generate resolution context\n        let context = this._planner.createContext(this);\n\n        // STEP 2: generate a resolutioin plan & link it to the context\n        this._planner.createPlan(context, binding, target);\n\n        // STEP 3, 4 & 5: use middleware (optional), execute resolution plan & activation\n        return (this._middleware !== null) ? this._middleware(context) : this._resolver.resolve<T>(context);\n    }\n\n}\n\nexport default Kernel;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nclass KeyValuePair<T> implements IKeyValuePair<T> {\n\n    public serviceIdentifier: (string|Symbol|any);\n    public value: Array<T>;\n\n    public constructor(serviceIdentifier: (string|Symbol|any), value: T) {\n        this.serviceIdentifier = serviceIdentifier;\n        this.value = new Array<T>();\n        this.value.push(value);\n    }\n}\n\nexport default KeyValuePair;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\n// TypeBinding\n// -----------\n\n// A dictionary with support for duplicate keys\n\nimport KeyValuePair from \"./key_value_pair\";\nimport * as ERROR_MSGS from \"../constants/error_msgs\";\n\nclass Lookup<T> implements ILookup<T> {\n\n\t// dictionary used store multiple values for each key <key>\n    private _dictionary: Array<IKeyValuePair<T>>;\n\n    public constructor() {\n        this._dictionary = new Array<IKeyValuePair<T>>();\n    }\n\n\t// adds a new KeyValuePair to _dictionary\n    public add(serviceIdentifier: (string|Symbol|any), value: T): void {\n\n        if (serviceIdentifier === null || serviceIdentifier === undefined) { throw new Error(ERROR_MSGS.NULL_ARGUMENT); };\n        if (value === null || value === undefined) { throw new Error(ERROR_MSGS.NULL_ARGUMENT); };\n\n        let index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            this._dictionary[index].value.push(value);\n        } else {\n            this._dictionary.push(new KeyValuePair(serviceIdentifier, value));\n        }\n    }\n\n    // gets the value of a KeyValuePair by its serviceIdentifier\n    public get(serviceIdentifier: (string|Symbol|any)): Array<T> {\n\n        if (serviceIdentifier === null || serviceIdentifier === undefined) { throw new Error(ERROR_MSGS.NULL_ARGUMENT); }\n\n        let index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            return this._dictionary[index].value;\n        } else {\n            throw new Error(ERROR_MSGS.KEY_NOT_FOUND);\n        }\n    }\n\n\t// removes a KeyValuePair from _dictionary by its serviceIdentifier\n    public remove(serviceIdentifier: (string|Symbol|any)): void {\n\n        if (serviceIdentifier === null || serviceIdentifier === undefined) { throw new Error(ERROR_MSGS.NULL_ARGUMENT); }\n\n        let index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            this._dictionary.splice(index, 1);\n        } else {\n            throw new Error(ERROR_MSGS.KEY_NOT_FOUND);\n        }\n    }\n\n    // returns true if _dictionary contains serviceIdentifier\n    public hasKey(serviceIdentifier: (string|Symbol|any)): boolean {\n\n        if (serviceIdentifier === null || serviceIdentifier === undefined) { throw new Error(ERROR_MSGS.NULL_ARGUMENT); }\n\n        let index = this.getIndexByKey(serviceIdentifier);\n        if (index !== -1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n\t// finds the location of a KeyValuePair pair in _dictionary by its serviceIdentifier\n    private getIndexByKey(serviceIdentifier: (string|Symbol|any)): number {\n        let index = -1;\n        for (let i = 0; i < this._dictionary.length; i++) {\n            let keyValuePair = this._dictionary[i];\n            if (keyValuePair.serviceIdentifier === serviceIdentifier) {\n                index = i;\n            }\n        }\n        return index;\n    }\n\n}\n\nexport default Lookup;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nclass Context<TService> implements IContext {\n\n    public kernel: IKernel;\n    public plan: IPlan;\n\n    public constructor(kernel: IKernel) {\n        this.kernel = kernel;\n    }\n\n    public addPlan(plan: IPlan) {\n        this.plan = plan;\n    }\n}\n\nexport default Context;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nclass Metadata implements IMetadata {\n\n  public key: string;\n  public value: any;\n\n  constructor(key: string, value: any) {\n      this.key = key;\n      this.value = value;\n  }\n}\n\nexport default Metadata;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nclass Plan implements IPlan {\n\n    public parentContext: IContext;\n    public rootRequest: IRequest;\n\n    public constructor(parentContext: IContext, rootRequest: IRequest) {\n        this.parentContext = parentContext;\n        this.rootRequest = rootRequest;\n    }\n}\n\nexport default Plan;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport Plan from \"./plan\";\nimport Context from \"./context\";\nimport Request from \"./request\";\nimport Target from \"./target\";\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\nimport * as ERROR_MSGS from \"../constants/error_msgs\";\nimport BindingType from \"../bindings/binding_type\";\n\nclass Planner implements IPlanner {\n\n    public createContext(kernel: IKernel): IContext {\n        return new Context(kernel);\n    }\n\n    public createPlan(context: IContext, binding: IBinding<any>, target: ITarget): IPlan {\n\n        let rootRequest = new Request(\n            binding.serviceIdentifier,\n            context,\n            null,\n            binding,\n            target);\n\n        let plan = new Plan(context, rootRequest);\n\n        // Plan and Context are duable linked\n        context.addPlan(plan);\n\n        let dependencies = this._getDependencies(binding.implementationType);\n        dependencies.forEach((dependency) => { this._createSubRequest(rootRequest, dependency); });\n        return plan;\n    }\n\n    public getBindings<T>(kernel: IKernel, serviceIdentifier: (string|Symbol|INewable<T>)): IBinding<T>[] {\n        let bindings: IBinding<T>[] = [];\n        let _kernel: any = kernel;\n        let _bindingDictionary = _kernel._bindingDictionary;\n        if (_bindingDictionary.hasKey(serviceIdentifier)) {\n            bindings = _bindingDictionary.get(serviceIdentifier);\n        }\n        return bindings;\n    }\n\n    public getActiveBindings(parentRequest: IRequest, target: ITarget): IBinding<any>[] {\n\n        let bindings = this.getBindings<any>(parentRequest.parentContext.kernel, target.serviceIdentifier);\n        let activeBindings: IBinding<any>[] = [];\n\n        if (bindings.length > 1 && target.isArray() === false) {\n\n            // apply constraints if available to reduce the number of active bindings\n            activeBindings = bindings.filter((binding) => {\n\n                let request =  new Request(\n                    binding.serviceIdentifier,\n                    parentRequest.parentContext,\n                    parentRequest,\n                    binding,\n                    target\n                );\n\n                return binding.constraint(request);\n\n            });\n\n        } else {\n            activeBindings = bindings;\n        }\n\n        return activeBindings;\n    }\n\n    private _createSubRequest(parentRequest: IRequest, target: ITarget) {\n\n        try {\n            let activeBindings = this.getActiveBindings(parentRequest, target);\n\n            if (activeBindings.length === 0) {\n\n                // no matching bindings found\n                let serviceIdentifier = parentRequest.parentContext.kernel.getServiceIdentifierAsString(target.serviceIdentifier);\n                throw new Error(`${ERROR_MSGS.NOT_REGISTERED} ${serviceIdentifier}`);\n\n            } else if (activeBindings.length > 1 && target.isArray() === false) {\n\n                // more than one matching binding found but target is not an array\n                let serviceIdentifier = parentRequest.parentContext.kernel.getServiceIdentifierAsString(target.serviceIdentifier);\n                throw new Error(`${ERROR_MSGS.AMBIGUOUS_MATCH} ${serviceIdentifier}`);\n\n            } else {\n\n                // one ore more than one matching bindings found \n                // when more than 1 matching bindings found target is an array \n                this._createChildRequest(parentRequest, target, activeBindings);\n\n            }\n\n        } catch (error) {\n            if (error instanceof RangeError) {\n                this._throwWhenCircularDependenciesFound(parentRequest.parentContext.plan.rootRequest);\n            } else {\n                throw new Error(error.message);\n            }\n        }\n    }\n\n    private _createChildRequest(parentRequest: IRequest, target: ITarget, bindings: IBinding<any>[]) {\n\n        // Use the only active binding to create a child request\n        let childRequest = parentRequest.addChildRequest(target.serviceIdentifier, bindings, target);\n        let subChildRequest = childRequest;\n\n        bindings.forEach((binding) => {\n\n            if (target.isArray()) {\n                subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);\n            }\n\n            // Only try to plan sub-dependencies when binding type is BindingType.Instance\n            if (binding.type === BindingType.Instance) {\n\n                // Create child requests for sub-dependencies if any\n                let subDependencies = this._getDependencies(binding.implementationType);\n                subDependencies.forEach((d, index) => {\n                    this._createSubRequest(subChildRequest, d);\n                });\n            }\n\n        });\n    }\n\n    private _throwWhenCircularDependenciesFound(\n        request: IRequest, previousServiceIdentifiers: (string|Symbol|INewable<any>)[] = []\n    ) {\n\n        previousServiceIdentifiers.push(request.serviceIdentifier);\n\n        request.childRequests.forEach((childRequest) => {\n\n            let serviceIdentifier = childRequest.serviceIdentifier;\n            if (previousServiceIdentifiers.indexOf(serviceIdentifier) === -1) {\n                if (childRequest.childRequests.length > 0) {\n                    this._throwWhenCircularDependenciesFound(childRequest, previousServiceIdentifiers);\n                } else {\n                    previousServiceIdentifiers.push(serviceIdentifier);\n                }\n            } else {\n                let tailServiceIdentifier = request.parentContext.kernel.getServiceIdentifierAsString(request.serviceIdentifier);\n                throw new Error(`${ERROR_MSGS.CIRCULAR_DEPENDENCY} ${serviceIdentifier} and ${tailServiceIdentifier}`);\n            }\n\n        });\n    }\n\n    private _getDependencies(func: Function): ITarget[] {\n\n        if (func === null) { return []; }\n        let constructorName = (<any>func).name;\n\n        // TypeScript compiler generated annotations\n        let targetsTypes = Reflect.getMetadata(METADATA_KEY.PARAM_TYPES, func);\n\n        // All types resolved bust be annotated with @injectable\n        if (targetsTypes === undefined) {\n            let msg = `${ERROR_MSGS.MISSING_INJECTABLE_ANNOTATION} ${constructorName}.`;\n            throw new Error(msg);\n        }\n\n        // User generated annotations\n        let targetsMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED, func) || [];\n\n        let targets: ITarget[] = [];\n\n        for (let i = 0; i < func.length; i++) {\n\n            let targetType = targetsTypes[i];\n            // Create map from array of metadata for faster access to metadata\n            let targetMetadata = targetsMetadata[i.toString()] || [];\n            let targetMetadataMap: any = {};\n            targetMetadata.forEach((m: IMetadata) => {\n                targetMetadataMap[m.key.toString()] = m.value;\n            });\n\n            // user generated metadata\n            let inject: any = targetMetadataMap[METADATA_KEY.INJECT_TAG];\n            let multiInject: any = targetMetadataMap[METADATA_KEY.MULTI_INJECT_TAG];\n            let targetName: any = targetMetadataMap[METADATA_KEY.NAME_TAG];\n\n            // Take type to be injected from user-generated metadata \n            // if not available use compiler-generated metadata\n            targetType = (inject || multiInject) ? (inject || multiInject) : targetType;\n\n            // Types Object and Function are too ambiguous to be resolved\n            // user needs to generate metadata manually for those\n            if (targetType === Object || targetType === Function || targetType === undefined) {\n                let msg = `${ERROR_MSGS.MISSING_INJECT_ANNOTATION} argument ${i} in class ${constructorName}.`;\n                throw new Error(msg);\n            }\n\n            // Create target\n            let target = new Target(targetName, targetType);\n            target.metadata = targetMetadata;\n            targets.push(target);\n\n        }\n\n        // Throw if a derived class does not implement its constructor explicitly\n        // We do this to prevent errors when a base class (parent) has dependencies \n        // and one of the derived classes (children) has no dependencies\n        if (targets.length === 0 && this._baseClassHasDepencencies(func)) {\n            throw new Error(`${ERROR_MSGS.MISSING_EXPLICIT_CONSTRUCTOR} ${constructorName}.`);\n        }\n\n        return targets;\n    }\n\n    private _baseClassHasDepencencies(func: Function): boolean {\n        let baseConstructor = Object.getPrototypeOf(func.prototype).constructor;\n        if (baseConstructor !== Object) {\n            if (baseConstructor.length > 0) {\n                return true;\n            } else {\n                return this._baseClassHasDepencencies(baseConstructor);\n            }\n        } else {\n            return false;\n        }\n    }\n}\n\nexport default Planner;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nclass QueryableString implements IQueryableString {\n\n  private str: string;\n\n  constructor(str: string) {\n    this.str = str;\n  }\n\n  public startsWith(searchString: string): boolean {\n    return this.str.indexOf(searchString) === 0;\n  }\n\n  public endsWith(searchString: string): boolean {\n    let reverseString = \"\";\n    let reverseSearchString = searchString.split(\"\").reverse().join(\"\");\n    reverseString = this.str.split(\"\").reverse().join(\"\");\n    return this.startsWith.call({ str : reverseString }, reverseSearchString);\n  }\n\n  public contains(searchString: string): boolean {\n    return (this.str.indexOf(searchString) !== -1);\n  }\n\n  public equals(compareString: string): boolean {\n    return this.str === compareString;\n  }\n\n  public value(): string {\n    return this.str;\n  }\n\n}\n\nexport default QueryableString;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nclass Request implements IRequest {\n\n        public serviceIdentifier: (string|Symbol|INewable<any>);\n        public parentContext: IContext;\n        public parentRequest: IRequest;\n        public bindings: IBinding<any>[];\n        public childRequests: IRequest[];\n        public target: ITarget;\n\n        public constructor(\n            serviceIdentifier: (string|Symbol|INewable<any>),\n            parentContext: IContext,\n            parentRequest: IRequest,\n            bindings: (IBinding<any>|IBinding<any>[]),\n            target: ITarget = null) {\n\n                this.serviceIdentifier = serviceIdentifier;\n                this.parentContext = parentContext;\n                this.parentRequest = parentRequest;\n                this.target = target;\n                this.childRequests = [];\n                this.bindings = (Array.isArray(bindings) ? bindings : ((bindings) ? [bindings] : []));\n        }\n\n        public addChildRequest(\n            serviceIdentifier: string,\n            bindings: (IBinding<any>|IBinding<any>[]),\n            target: ITarget): IRequest {\n\n                let child = new Request(\n                    serviceIdentifier,\n                    this.parentContext,\n                    this,\n                    bindings,\n                    target\n                );\n                this.childRequests.push(child);\n                return child;\n        }\n}\n\nexport default Request;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport Metadata from \"../planning/metadata\";\nimport QueryableString from \"./queryable_string\";\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\n\nclass Target implements ITarget {\n\n  public serviceIdentifier: (string|Symbol|INewable<any>);\n  public name: QueryableString;\n  public metadata: Array<IMetadata>;\n\n  constructor(name: string, serviceIdentifier: (string|Symbol|INewable<any>), namedOrTagged?: (string|IMetadata)) {\n\n    this.serviceIdentifier = serviceIdentifier;\n    this.name = new QueryableString(name || \"\");\n    this.metadata = new Array<IMetadata>();\n    let metadataItem: IMetadata = null;\n\n    // is named target\n    if (typeof namedOrTagged === \"string\") {\n        metadataItem = new Metadata(METADATA_KEY.NAMED_TAG, namedOrTagged);\n    } else if (namedOrTagged instanceof Metadata) {\n        // is target with metadata\n        metadataItem = namedOrTagged;\n    }\n\n    // target has metadata\n    if (metadataItem !== null) {\n        this.metadata.push(metadataItem);\n    }\n  }\n\n  public hasTag(key: string): boolean {\n    for (let i = 0; i < this.metadata.length; i++) {\n      let m = this.metadata[i];\n      if (m.key === key) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public isArray(): boolean {\n      return this.hasTag(METADATA_KEY.MULTI_INJECT_TAG);\n  }\n\n  public matchesArray(name: string|Symbol|any): boolean {\n    return this.matchesTag(METADATA_KEY.MULTI_INJECT_TAG)(name);\n  }\n\n  public isNamed(): boolean {\n      return this.hasTag(METADATA_KEY.NAMED_TAG);\n  }\n\n  public isTagged(): boolean {\n    if (this.metadata.length > 1) {\n        return true;\n    } else if (this.metadata.length === 1) {\n        // NAMED_TAG is not considered a tagged binding\n        return !this.hasTag(METADATA_KEY.NAMED_TAG);\n    } else {\n        return false;\n    }\n  }\n\n  public matchesNamedTag(name: string): boolean {\n    return this.matchesTag(METADATA_KEY.NAMED_TAG)(name);\n  }\n\n  public matchesTag(key: string) {\n    return (value: any) => {\n        for (let i = 0; i < this.metadata.length; i++) {\n            let m = this.metadata[i];\n            if (m.key === key && m.value === value) {\n                return true;\n            }\n        }\n        return false;\n    };\n  }\n\n}\n\nexport default Target;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingScope from \"../bindings/binding_scope\";\nimport BindingType from \"../bindings/binding_type\";\nimport * as ERROR_MSGS from \"../constants/error_msgs\";\n\nclass Resolver implements IResolver {\n\n    public resolve<Service>(context: IContext): Service {\n        let rootRequest = context.plan.rootRequest;\n        return this._resolve(rootRequest);\n    }\n\n    private _resolve(request: IRequest): any {\n\n        let bindings = request.bindings;\n        let childRequests = request.childRequests;\n\n        if (\n            request.target && request.target.isArray() &&\n            (!request.parentRequest.target || !request.parentRequest.target.matchesArray(request.target.serviceIdentifier))\n        ) {\n\n            // Create an array instead of creating an instance\n            return childRequests.map((childRequest) => { return this._resolve(childRequest); });\n\n        } else {\n\n            let result: any = null;\n            let binding = bindings[0];\n            let isSingleton = binding.scope === BindingScope.Singleton;\n\n            if (isSingleton && binding.activated === true) {\n                return binding.cache;\n            }\n\n            switch (binding.type) {\n\n                case BindingType.Value:\n                    result = binding.cache;\n                    break;\n\n                case BindingType.Constructor:\n                    result = binding.implementationType;\n                    break;\n\n                case BindingType.Factory:\n                    result = binding.factory(request.parentContext);\n                    break;\n\n                case BindingType.Provider:\n                    result = binding.provider(request.parentContext);\n                    break;\n\n                case BindingType.Instance:\n\n                    let constr = binding.implementationType;\n\n                    if (childRequests.length > 0) {\n                        let injections = childRequests.map((childRequest) => {\n                            return this._resolve(childRequest);\n                        });\n\n                        result = this._createInstance(constr, injections);\n                    } else {\n                        result = new constr();\n                    }\n\n                    break;\n\n                case BindingType.Invalid:\n                default:\n                    // The user probably created a binding but didn't finish it\n                    // e.g. kernel.bind<T>(\"ISomething\"); missing BindingToSyntax\n                    let serviceIdentifier = request.parentContext.kernel.getServiceIdentifierAsString(request.serviceIdentifier);\n                    throw new Error(`${ERROR_MSGS.INVALID_BINDING_TYPE} ${serviceIdentifier}`);\n            }\n\n            // use activation handler if available\n            if (typeof binding.onActivation === \"function\") {\n                result = binding.onActivation(request.parentContext, result);\n            }\n\n            // store in cache if scope is singleton\n            if (isSingleton) {\n                binding.cache = result;\n                binding.activated = true;\n            }\n\n            return result;\n        }\n\n    }\n\n    private _createInstance(Func: { new(...args: any[]) : any }, injections: Object[]) {\n        return new Func(...injections);\n    }\n\n}\n\nexport default Resolver;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingScope from \"../bindings/binding_scope\";\nimport BindingWhenOnSyntax from \"./binding_when_on_syntax\";\n\nclass BindingInSyntax<T> implements IBindingInSyntax<T> {\n\n    private _binding: IBinding<T>;\n\n    public constructor(binding: IBinding<T>) {\n        this._binding = binding;\n    }\n\n    public inSingletonScope(): IBindingWhenOnSyntax<T> {\n        this._binding.scope = BindingScope.Singleton;\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n}\n\nexport default BindingInSyntax;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingInSyntax from \"./binding_in_syntax\";\nimport BindingWhenSyntax from \"./binding_when_syntax\";\nimport BindingOnSyntax from \"./binding_on_syntax\";\n\nclass BindingInWhenOnSyntax<T> implements IBindingInSyntax<T>, IBindingWhenSyntax<T>, IBindingOnSyntax<T>  {\n\n    private _bindingInSyntax: BindingInSyntax<T>;\n    private _bindingWhenSyntax: IBindingWhenSyntax<T>;\n    private _bindingOnSyntax: IBindingOnSyntax<T>;\n    private _binding: IBinding<T>;\n\n    public constructor(binding: IBinding<T>) {\n        this._binding = binding;\n        this._bindingWhenSyntax = new BindingWhenSyntax<T>(this._binding);\n        this._bindingOnSyntax = new BindingOnSyntax<T>(this._binding);\n        this._bindingInSyntax = new BindingInSyntax<T>(binding);\n    }\n\n    public inSingletonScope(): IBindingWhenOnSyntax<T> {\n        return this._bindingInSyntax.inSingletonScope();\n    }\n\n    public when(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.when(constraint);\n    }\n\n    public whenTargetNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenTargetNamed(name);\n    }\n\n    public whenTargetTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenTargetTagged(tag, value);\n    }\n\n    public whenInjectedInto(parent: (Function|string)): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenInjectedInto(parent);\n    }\n\n    public whenParentNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenParentNamed(name);\n    }\n\n    public whenParentTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenParentTagged(tag, value);\n    }\n\n    public whenAnyAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);\n    }\n\n    public whenNoAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);\n    }\n\n    public whenAnyAncestorNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);\n    }\n\n    public whenAnyAncestorTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);\n    }\n\n    public whenNoAncestorNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorNamed(name);\n    }\n\n    public whenNoAncestorTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);\n    }\n\n    public whenAnyAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);\n    }\n\n    public whenNoAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);\n    }\n\n    public onActivation(handler: (context: IContext, injectable: T) => T): IBindingWhenSyntax<T> {\n        return this._bindingOnSyntax.onActivation(handler);\n    }\n\n}\n\nexport default BindingInWhenOnSyntax;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingWhenSyntax from \"./binding_when_syntax\";\n\nclass BindingOnSyntax<T> implements IBindingOnSyntax<T> {\n\n    private _binding: IBinding<T>;\n\n    public constructor(binding: IBinding<T>) {\n        this._binding = binding;\n    }\n\n    public onActivation(handler: (context: IContext, injectable: T) => T): IBindingWhenSyntax<T> {\n        this._binding.onActivation = handler;\n        return new BindingWhenSyntax<T>(this._binding);\n    }\n\n}\n\nexport default BindingOnSyntax;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingInWhenOnSyntax from \"./binding_in_when_on_syntax\";\nimport BindingWhenOnSyntax from \"./binding_when_on_syntax\";\nimport BindingType from \"../bindings/binding_type\";\n\nclass BindingToSyntax<T> implements IBindingToSyntax<T> {\n\n    private _binding: IBinding<T>;\n\n    public constructor(binding: IBinding<T>) {\n        this._binding = binding;\n    }\n\n    public to(constructor: { new(...args: any[]): T; }): IBindingInWhenOnSyntax<T> {\n        this._binding.type = BindingType.Instance;\n        this._binding.implementationType = constructor;\n        return new BindingInWhenOnSyntax<T>(this._binding);\n    }\n\n    public toValue(value: T): IBindingWhenOnSyntax<T> {\n        this._binding.type = BindingType.Value;\n        this._binding.cache = value;\n        this._binding.implementationType = null;\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n    public toConstructor<T2>(constructor: INewable<T2>): IBindingWhenOnSyntax<T> {\n        this._binding.type = BindingType.Constructor;\n        this._binding.implementationType = <any>constructor;\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n    public toFactory<T2>(factory: IFactoryCreator<T2>): IBindingWhenOnSyntax<T> {\n        this._binding.type = BindingType.Factory;\n        this._binding.factory = <any>factory;\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n    public toAutoFactory<T2>(serviceIdentifier: (string|Symbol|INewable<T2>)): IBindingWhenOnSyntax<T> {\n        this._binding.type = BindingType.Factory;\n        this._binding.factory = (context) => {\n            return () => {\n                return context.kernel.get<T2>(serviceIdentifier);\n            };\n        };\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n    public toProvider<T2>(provider: IProviderCreator<T2>): IBindingWhenOnSyntax<T> {\n        this._binding.type = BindingType.Provider;\n        this._binding.provider = <any>provider;\n        return new BindingWhenOnSyntax<T>(this._binding);\n    }\n\n}\n\nexport default BindingToSyntax;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingWhenSyntax from \"./binding_when_syntax\";\nimport BindingOnSyntax from \"./binding_on_syntax\";\n\nclass BindingWhenOnSyntax<T> implements IBindingWhenSyntax<T>, IBindingOnSyntax<T> {\n\n    private _bindingWhenSyntax: IBindingWhenSyntax<T>;\n    private _bindingOnSyntax: IBindingOnSyntax<T>;\n    private _binding: IBinding<T>;\n\n    public constructor(binding: IBinding<T>) {\n        this._binding = binding;\n        this._bindingWhenSyntax = new BindingWhenSyntax<T>(this._binding);\n        this._bindingOnSyntax = new BindingOnSyntax<T>(this._binding);\n    }\n\n    public when(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.when(constraint);\n    }\n\n    public whenTargetNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenTargetNamed(name);\n    }\n\n    public whenTargetTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenTargetTagged(tag, value);\n    }\n\n    public whenInjectedInto(parent: (Function|string)): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenInjectedInto(parent);\n    }\n\n    public whenParentNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenParentNamed(name);\n    }\n\n    public whenParentTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenParentTagged(tag, value);\n    }\n\n    public whenAnyAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);\n    }\n\n    public whenNoAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);\n    }\n\n    public whenAnyAncestorNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);\n    }\n\n    public whenAnyAncestorTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);\n    }\n\n    public whenNoAncestorNamed(name: string): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorNamed(name);\n    }\n\n    public whenNoAncestorTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);\n    }\n\n    public whenAnyAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);\n    }\n\n    public whenNoAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);\n    }\n\n    public onActivation(handler: (context: IContext, injectable: T) => T): IBindingWhenSyntax<T> {\n        return this._bindingOnSyntax.onActivation(handler);\n    }\n\n}\n\nexport default BindingWhenOnSyntax;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport BindingOnSyntax from \"./binding_on_syntax\";\nimport { traverseAncerstors, taggedConstraint, namedConstraint, typeConstraint } from \"./constraint_helpers\";\n\nclass BindingWhenSyntax<T> implements IBindingWhenSyntax<T> {\n\n    private _binding: IBinding<T>;\n\n    public constructor(binding: IBinding<T>) {\n        this._binding = binding;\n    }\n\n    public when(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n        this._binding.constraint = constraint;\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenTargetNamed(name: string): IBindingOnSyntax<T> {\n        this._binding.constraint = namedConstraint(name);\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenTargetTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        this._binding.constraint = taggedConstraint(tag)(value);\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenInjectedInto(parent: (Function|string)): IBindingOnSyntax<T> {\n        this._binding.constraint = (request: IRequest) => {\n            return typeConstraint(parent)(request.parentRequest);\n        };\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenParentNamed(name: string): IBindingOnSyntax<T> {\n        this._binding.constraint = (request: IRequest) => {\n            return namedConstraint(name)(request.parentRequest);\n        };\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenParentTagged(tag: string, value: any): IBindingOnSyntax<T> {\n        this._binding.constraint = (request: IRequest) => {\n            return taggedConstraint(tag)(value)(request.parentRequest);\n        };\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenAnyAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T> {\n        this._binding.constraint = (request: IRequest) => {\n            return traverseAncerstors(request, typeConstraint(ancestor));\n        };\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenNoAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T> {\n        this._binding.constraint = (request: IRequest) => {\n            return !traverseAncerstors(request, typeConstraint(ancestor));\n        };\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenAnyAncestorNamed(name: string): IBindingOnSyntax<T> {\n\n        this._binding.constraint = (request: IRequest) => {\n            return traverseAncerstors(request, namedConstraint(name));\n        };\n\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenNoAncestorNamed(name: string): IBindingOnSyntax<T> {\n\n        this._binding.constraint = (request: IRequest) => {\n            return !traverseAncerstors(request, namedConstraint(name));\n        };\n\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenAnyAncestorTagged(tag: string, value: any): IBindingOnSyntax<T> {\n\n        this._binding.constraint = (request: IRequest) => {\n            return traverseAncerstors(request, taggedConstraint(tag)(value));\n        };\n\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenNoAncestorTagged(tag: string, value: any): IBindingOnSyntax<T> {\n\n        this._binding.constraint = (request: IRequest) => {\n            return !traverseAncerstors(request, taggedConstraint(tag)(value));\n        };\n\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenAnyAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n\n        this._binding.constraint = (request: IRequest) => {\n            return traverseAncerstors(request, constraint);\n        };\n\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n    public whenNoAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T> {\n\n        this._binding.constraint = (request: IRequest) => {\n            return !traverseAncerstors(request, constraint);\n        };\n\n        return new BindingOnSyntax<T>(this._binding);\n    }\n\n}\n\nexport default BindingWhenSyntax;\n","///<reference path=\"../interfaces/interfaces.d.ts\" />\n\nimport * as METADATA_KEY from \"../constants/metadata_keys\";\n\nlet traverseAncerstors = (request: IRequest, constraint: (request: IRequest) => boolean): boolean => {\n    let parent = request.parentRequest;\n    if (parent !== null) {\n        return constraint(parent) ? true : traverseAncerstors(parent, constraint);\n    } else {\n        return false;\n    }\n};\n\n// This helpers use currying to help you to generate constraints\n\nlet taggedConstraint = (key: string) => (value: any) => (request: IRequest) => {\n    return request.target.matchesTag(key)(value);\n};\n\nlet namedConstraint = taggedConstraint(METADATA_KEY.NAMED_TAG);\n\nlet typeConstraint = (type: (Function|string)) => (request: IRequest) => {\n\n    // Using index 0 because constraints are applied \n    // to one binding at a time (see Planner class)\n    let binding = request.bindings[0];\n\n    if (typeof type === \"string\") {\n        let serviceIdentifier = binding.serviceIdentifier;\n        return serviceIdentifier === type;\n    } else {\n        let constructor = request.bindings[0].implementationType;\n        return type === constructor;\n    }\n};\n\nexport { traverseAncerstors, taggedConstraint, namedConstraint, typeConstraint };\n"],"sourceRoot":"/source/"}